{"Questions":[{"Text":"Зачем нужна консоль в Unity?","Answers":["Отображение ошибок, ворнингов и логов.","Просмотр и редактирование текстовых файлов.","Загрузка пакетов и ассетов.","Выполнение инструкций командной строки"],"CorrectAnswerIndex":0,"Explanation":"Консоль в Unity - это инструмент для отображения сообщений и вывода информации о работе приложения во время его выполнения. Она играет важную роль в процессе разработки и отладки игр и приложений.","Difficulty":1},{"Text":"Что такое префабы (Prefabs) в Unity3D?","Answers":["Это объекты, которые можно использовать для создания копий в сцене.","Это готовые 3D модели для использования на сцене.","Это скрипты для управления игровым процессом.","Это компоненты для работы с физикой объектов."],"CorrectAnswerIndex":0,"Explanation":"Префабы (Prefabs) в Unity3D представляют собой шаблоны объектов, которые можно создавать, настраивать и использовать множество раз на сцене. Они позволяют создавать однотипные объекты с одним и тем же набором компонентов, свойств и настроек.\n\nКогда вы создаете префаб, он становится своеобразным \"макетом\" объекта, и его экземпляры на сцене будут отображаться так же, как исходный префаб, с возможностью внесения индивидуальных изменений для каждого экземпляра.","Difficulty":2},{"Text":"Какие данные в себе хранит меш?","Answers":["Меш хранит данные о атрибутах, определяющих внешний вид объекта.","Меш хранит информацию о координатах объекта в игровом пространстве.","Меш хранит данные о характеристиках процессора и оперативной памяти компьютера для оптимизации производительности.","Меш хранит данные о пользовательском вводе и управлении для обработки действий игрока в игровом движке."],"CorrectAnswerIndex":0,"Explanation":"Меш определяет форму и внешний вид объекта, включая его вершины, грани, текстурные координаты и другие атрибуты. \nВершины (Vertices): Меш содержит список вершин, которые определяют позицию точек в трехмерном пространстве. \nГрани (Faces): Меш определяет грани, которые соединяют вершины и определяют форму объекта. Грани могут быть треугольниками, четырехугольниками или полигонами более сложной формы.\nНормали (Normals): Нормали указывают направление поверхности в каждой вершине и используются для расчета освещения и отражения света от объекта.\nТекстурные координаты (Texture Coordinates): Меш может содержать текстурные координаты, которые связывают вершины с соответствующими точками на текстуре. ","Difficulty":3},{"Text":"Что такое метод?","Answers":["Набор инструкций.","Это объект, который содержит данные и поведение класса.","Это свойство объекта, которое хранит данные для класса.","Часть интерфейса."],"CorrectAnswerIndex":0,"Explanation":"Метод - это блок кода, объединенный внутри класса в объектно-ориентированном программировании, который выполняет определенные операции или действия. Методы представляют собой функции, которые могут принимать параметры, выполнять вычисления, взаимодействовать с данными класса и возвращать результаты.\n\nОни являются основными строительными блоками поведения классов и позволяют выполнить определенные действия над объектами данного класса. Методы определяют поведение объектов и дает возможность использовать их в коде программы, вызывая методы и передавая необходимые аргументы.","Difficulty":3},{"Text":"Что такое canvas?","Answers":["Это компонент, который используется для отображения пользовательского интерфейса.","Это библиотека для работы с графикой и изображениями в Unity.","Canvas в Unity используется для рисования текстур и спрайтов на экране.","Это панель управления настройками и настроек проекта в Unity."],"CorrectAnswerIndex":0,"Explanation":"Canvas (холст) в Unity - это компонент, который используется для отображения пользовательского интерфейса (UI) на экране. Он представляет собой плоскую поверхность, на которой размещаются различные элементы UI, такие как текст, изображения, кнопки и другие интерактивные элементы.\n\nCanvas позволяет создавать гибкий и адаптивный пользовательский интерфейс, который автоматически масштабируется и подстраивается под разные разрешения экрана и устройства.","Difficulty":4},{"Text":"Что такое ООП?","Answers":["Парадигма, которая ориентирована на описание программных систем в терминах объектов и их взаимодействия.","Методология программирования, главная цель которой сделать код максимально линейным.","Технология, позволяющая взаимодействовать с цифровыми системами на естественных языках.","Способ организации кода, в котором все операции выполняются последовательно, без использования абстракций."],"CorrectAnswerIndex":0,"Explanation":"ООП, или объектно-ориентированное программирование, это методология программирования, которая ориентирована на организацию кода в виде объектов, которые представляют реальные сущности или абстракции. В объектно-ориентированном программировании данные и функции, которые с ними связаны, объединяются в единые сущности, называемые объектами.","Difficulty":5},{"Text":"Что такое класс?","Answers":["Тип данных, определяемый пользователем.","Это объект, который содержит данные и поведение программы.","Это тип данных, который используется для хранения числовых значений.","Это функция, которая выполняет определенные действия в программе."],"CorrectAnswerIndex":0,"Explanation":"\nКласс - это шаблон или описание, которое определяет состояние (поля) и поведение (методы) объектов в ООП. Класс является фундаментальной концепцией ООП и служит для создания объектов - экземпляров класса.\n\nКласс определяет общие характеристики для группы объектов, которые будут созданы на его основе. Он объединяет данные (поля) и операции (методы), которые связаны с определенной сущностью, и определяет поведение и свойства, которыми обладают объекты этого класса.","Difficulty":5},{"Text":"Зачем нужен аниматор?","Answers":["Позволяет создавать и управлять различными анимациями, переходами и параметрами.","Предназначен для создания и редактирования 3D моделей.","Предоставляет инструменты для работы с физическими эффектами и симуляциями.","Позволяет создавать мультфильмы в Unity."],"CorrectAnswerIndex":0,"Explanation":"Аниматор в Unity - это компонент, который позволяет создавать и управлять анимациями объектов на сцене. \nНекоторые из основных возможностей:\nСоздание анимаций с использованием графического редактора Animator Controller.\nУправление параметрами анимаций для плавного перехода между состояниями анимации.\nПрименение анимаций к различным состояниям объектов (например, покой, движение, атака и т. д.).\nСинхронизация анимаций с другими компонентами и событиями в игре.\nСоздание анимаций с помощью скриптов, чтобы обеспечить динамичные и реагирующие на действия игроков анимации.","Difficulty":6},{"Text":"Какой компонент Unity3D используется для воспроизведения звуковых эффектов?","Answers":["Audio Source","Camera","Light","Particle System"],"CorrectAnswerIndex":0,"Explanation":"Для воспроизведения звуковых эффектов в Unity3D используется компонент AudioSource. Компонент AudioSource позволяет управлять воспроизведением звуковых файлов, таких как аудио эффекты, звуки среды, музыка и т.д.\n\nВы можете добавить компонент AudioSource к любому игровому объекту, который будет играть звуковой эффект, и настроить его свойства, такие как аудио-файл для воспроизведения, громкость, позицию в пространстве и т.д. Кроме того, AudioSource имеет методы для управления воспроизведением, такие как Play() для начала воспроизведения, Pause() для паузы, Stop() для остановки и т.д.","Difficulty":7},{"Text":"Какой компонент Unity3D используется для отображения текста на сцене?","Answers":["Text Mesh Pro","Light","Collider","Particle System"],"CorrectAnswerIndex":0,"Explanation":"Text Mesh Pro (TMP) - это пакет и компонент для работы с текстом в Unity, предоставляющий богатый набор возможностей и улучшений по сравнению с стандартным компонентом Text. Он разработан и поддерживается компанией Unity Technologies.","Difficulty":7},{"Text":"Что такое суперкласс?","Answers":["Класс, явлющийся родительским, от которого наследуют другие.","Класс, который произведен от нескольких подклассов одновременно.","Класс, который не может иметь своего собственного кода и может только наследовать код из других классов.","Класс, который используется только в статических контекстах программы."],"CorrectAnswerIndex":0,"Explanation":"Суперкласс (также называемый родительским классом или базовым классом) в объектно-ориентированном программировании представляет собой класс, от которого произошел другой класс, называемый подклассом или дочерним классом.\n\nПри наследовании, класс-потомок (подкласс) наследует атрибуты и методы класса-предка (суперкласса) и может добавлять свои собственные атрибуты и методы. В этом смысле суперкласс предоставляет общий набор функциональности, который может быть переиспользован в нескольких подклассах, способствуя повторному использованию кода и поддержке принципов абстракции и инкапсуляции.","Difficulty":8},{"Text":"Что такое MonoBehaviour? ","Answers":["Это базовый класс в Unity, который позволяет создавать и прикреплять компоненты к игровым объектам.","Это компонент, который отвечает за создание физических объектов в игре.","Это среда разработки для создания пользовательского интерфейса в Unity.","Это базовый класс, который предоставляет доступ к базовым математическим операциям в Unity."],"CorrectAnswerIndex":0,"Explanation":"MonoBehaviour - это базовый класс в Unity, который позволяет создавать компоненты, взаимодействующие с объектами на сцене. Класс MonoBehaviour предоставляет возможность добавлять поведение к игровым объектам, таким как персонажи, предметы, камеры, и т.д.\n\nПри создании скриптов в Unity, они должны быть унаследованы от MonoBehaviour. Это позволяет использовать различные методы MonoBehaviour, такие как Start(), Update(), FixedUpdate(), и другие, которые автоматически вызываются движком Unity в определенные моменты жизненного цикла объекта.","Difficulty":9},{"Text":"Какой компонент Unity3D позволяет объектам взаимодействовать с другими объектами на сцене через коллизии и триггеры?","Answers":["Collider","Mesh Renderer","Camera","Light"],"CorrectAnswerIndex":0,"Explanation":"Collider - это базовый компонент, который позволяет определить границы и форму объекта для обнаружения столкновений с другими объектами. Collider не обрабатывает логику столкновений, а просто определяет области, которые могут взаимодействовать с другими коллайдерами.","Difficulty":9},{"Text":"Что в иерархии используется для организации игровых объектов в группы?","Answers":["Empty objects","Canvas"," Event systems","Mesh renderers"],"CorrectAnswerIndex":0,"Explanation":"Occlusion map (карта заслонения) - это текстурная карта, которая используется для определения видимости объектов на сцене относительно источника света или камеры. \n\nОсновное предназначение occlusion map состоит в том, чтобы определить, какие пиксели объектов находятся в тени или скрыты другими объектами на сцене. Это позволяет исключить ненужные пиксели из процесса освещения и рендеринга, что увеличивает производительность и позволяет создавать более реалистичные и детализированные сцены.","Difficulty":10},{"Text":"Что такое конструктор?","Answers":["Особый метод с именем класса, который запускается при инициализации класса.","Это специальный метод, который вызывается в классе для завершения работы программы.","Это метод, который вызывается в классе во время компиляции.","Особый метод, который используется для передачи данных между различными классами."],"CorrectAnswerIndex":0,"Explanation":"Конструктор - это специальный метод в классе, который вызывается автоматически при создании объекта данного класса. \n\nОсновная задача конструктора - обеспечить корректное инициализацию объекта перед его использованием. Он позволяет задать значения полям класса и выполнить другие настройки, чтобы объект был готов к работе сразу после создания.\n\nВ языке C#, имя конструктора совпадает с именем класса. Конструктор может быть перегружен, что означает, что в классе может быть несколько конструкторов с разными параметрами. ","Difficulty":11},{"Text":"Какой метод в MonoBehaviour вызывается при активации объекта на сцене?","Answers":["OnEnable","OnStart","OnActivate","OnAttach"],"CorrectAnswerIndex":0,"Explanation":"Метод OnEnable() - это метод в Unity, который вызывается каждый раз, когда компонент становится активным на сцене. Он выполняется после метода Awake() при активации объекта или после включения компонента в объекте.","Difficulty":11},{"Text":"Что такое объект в ООП?","Answers":[" Это экземпляр класса.","Это свойство класса, которое хранит данные для последующего использования.","Это принцип программирования, который гласит, что каждый класс должен иметь только один объект.","Это значение."],"CorrectAnswerIndex":0,"Explanation":"Объект - это экземпляр класса в ООП. Класс определяет структуру и поведение объектов, а объект представляет конкретный экземпляр этого класса, обладающий уникальным состоянием и поведением.\n\nКласс - это шаблон или описание, которое определяет свойства (поля) и методы (функции), которыми обладает объект данного класса. Он является абстракцией, определяющей общие характеристики для группы объектов.\n\nОбъект - это конкретное воплощение класса со своими уникальными значениями свойств и поведением.","Difficulty":12},{"Text":"Что такое обработка исключений?","Answers":["Механизм перехвата и обработки ошибок для избежания прекращения работы или падения программы.","Механизм уведомления пользователя о проблемах в программе.","Механизм экстренного прекращения работы программы в случае перехвата ошибок.","Механизм для игнорирования ошибок выполнения программы."],"CorrectAnswerIndex":0,"Explanation":"Обработка исключений - это механизм, который позволяет обрабатывать и управлять ошибками и исключительными ситуациями в программе. Когда возникает исключение, это сигнализирует о нестандартной ситуации или ошибке, которая может повлиять на нормальное выполнение программы.\n\nВместо того чтобы допустить аварийное завершение программы при возникновении исключения, обработка исключений позволяет перехватить и обработать ошибку, предпринять соответствующие действия или продолжить выполнение программы с учетом возникшей ситуации.","Difficulty":13},{"Text":"Какой из следующих компонентов Unity3D используется для работы с физикой и столкновениями объектов?","Answers":["Rigidbody","Transform","Audio Listener"," Mesh Renderer"],"CorrectAnswerIndex":0,"Explanation":"Компонент Unity3D, который используется для работы с физикой и столкновениями объектов, называется \"Rigidbody\". Rigidbody добавляется к объектам, чтобы имитировать физическое поведение, такое как гравитация, столкновения и взаимодействия с другими объектами в сцене.","Difficulty":13},{"Text":"При создании ресурсов, таких как меши для Unity, какую единицу измерения рекомендуется использовать?","Answers":["Метры","Футы","Кубиты","Дюймы"],"CorrectAnswerIndex":0,"Explanation":"Основной единицей измерения в Unity является метр (meter). Все размеры и координаты объектов в сцене задаются в метрах.","Difficulty":14},{"Text":"Для чего нужны нормали?","Answers":["Нормали указывают на направление поверхности и используются для определения, как свет будет взаимодействовать с объектом.","Нормали используются для определения глубины и плотности объекта в трехмерном пространстве.","Нормали служат для управления физическими свойствами объекта, такими как его масса и трение.","Нормали используются для определения аудио-эффектов и звуковых свойств объекта."],"CorrectAnswerIndex":0,"Explanation":"Нормали в трехмерной графике используются для определения направления поверхности в каждой вершине меша. Они используются для расчета освещения объектов. Освещение зависит от угла между нормалями поверхности и направлением источника света. Это позволяет создавать реалистичные эффекты светотени и отражений на поверхностях объектов. Нормали также используются для расчета теней. По мере движения источника света, нормали помогают определить, какие части объекта должны находиться в тени, а какие - на свету.\n\nЕще нормали могут быть использованы для расчета столкновений и коллизий объектов. \n","Difficulty":15},{"Text":"Какой компонент Unity3D отвечает за управление анимациями объектов на сцене?","Answers":["Animator","Rigidbody","Collider","Audio Source"],"CorrectAnswerIndex":0,"Explanation":"Компонент Unity3D, который отвечает за управление анимациями объектов на сцене, называется \"Animator\". Он используется для создания и управления состояниями анимации, а также для переходов между ними на основе определенных условий или параметров. С помощью компонента Animator можно создавать сложные анимационные контроллеры и управлять движениями и поведением объектов в игре.","Difficulty":15},{"Text":"В чем разница между ошибкой и исключением?","Answers":["Ошибка - дефект в программе.\nИсключение - событие,которое возникает в результате ошибки.","Ошибки - это специальные объекты, которые создаются в программе для обработки исключительных ситуаций.","Ошибки возникают только во время выполнения программы, а исключения - только во время компиляции.","Ошибки и исключения - это синонимы и используются взаимозаменяемо в программировании."],"CorrectAnswerIndex":0,"Explanation":"Ошибки - это непредвиденные проблемы в программе, которые приводят к сбою, в то время как исключения - это специальные сигналы о нестандартных ситуациях, которые можно перехватить и обработать в программе для устранения проблемы без аварийного завершения программы.","Difficulty":16},{"Text":"Какой метод в MonoBehaviour вызывается перед уничтожением объекта на сцене?","Answers":["OnDestroy","OnDisable","OnAwake","OnDelete"],"CorrectAnswerIndex":0,"Explanation":"Метод OnDestroy в MonoBehaviour вызывается перед уничтожением объекта на сцене. Этот метод предоставляет возможность выполнить дополнительные действия или освободить ресурсы, связанные с объектом, перед тем, как он будет удален из памяти.","Difficulty":17},{"Text":"Что делает свойство IsKinematic на компоненте Rigidbody?","Answers":["Оно отключает физические взаимодействия на объект, позволяя производить преобразования только вручную из кода.","Оно убирает гравитацию объекта, но сохраняет все другие силы.","Снимает с объекта все физические силы, кроме гравитации.","Он преобразует объект в физические силы, которые воздействуют на другие объекты."],"CorrectAnswerIndex":0,"Explanation":"Свойство IsKinematic на компоненте Rigidbody в Unity указывает, будет ли объект подвержен физическому взаимодействию с другими объектами в сцене. Когда значение IsKinematic установлено в true, объект не будет реагировать на силы и столкновения, вызванные физическим движением других объектов или гравитацией.\n\nТаким образом, объект с включенным IsKinematic будет двигаться и взаимодействовать с окружающей средой только с помощью своего кода или анимаций, а не с помощью стандартной физической системы Unity. Это может быть полезно, когда нужно контролировать движение объекта сцены напрямую, без влияния на него физических сил.","Difficulty":17},{"Text":"Какой компонент Unity3D используется для отображения 3D моделей на сцене?","Answers":["Mesh Renderer","Light","Collider","Camera"],"CorrectAnswerIndex":0,"Explanation":"Компонент Mesh Renderer отвечает за отрисовку графической информации, представленной в виде меша (3D модели), на экране. Он работает в сочетании с компонентом Mesh Filter, который содержит собственно меш (3D модель), а также с материалами (Materials), определяющими внешний вид объекта.\n\nКомпонент Mesh Renderer содержит параметры, такие как материалы, настройки освещения, смещение и масштабирование текстур и другие параметры, позволяющие управлять внешним видом отображаемых 3D объектов.","Difficulty":18},{"Text":"Что означает модификатор virtual?","Answers":["Модификатор virtual указывает, что метод может быть переопределен.","Модификатор virtual указывает, что метод является абстрактным и требует реализации в каждом производном классе.","Модификатор virtual указывает, что метод может быть вызван только из других методов в том же классе.","Модификатор virtual указывает, что метод доступен только в пределах текущего класса и не может быть наследован."],"CorrectAnswerIndex":0,"Explanation":"Когда метод объявлен с модификатором virtual, он может быть переопределен (или замещен) в производных классах с помощью модификатора override. Это позволяет производным классам предоставлять свою собственную реализацию метода, замещая реализацию из базового класса.","Difficulty":19},{"Text":"Где доступны члены с модификатором public?","Answers":["Из любого места программы, включая другие классы и пространства имен.","Только внутри того же проекта (сборки).","Внутри того же класса и его производных классов (наследников).","Только внутри того же класса, в котором они объявлены."],"CorrectAnswerIndex":0,"Explanation":"Члены с модификатором public доступны из любого места программы, включая другие классы и пространства имен. Это означает, что из любого кода, включая код в других классах, объектах или даже в других сборках (проектах), можно обращаться к публичным членам класса.","Difficulty":19},{"Text":"Какое отличие deltaTime и fixedDeltaTime?","Answers":["deltaTime это время между кадрами, а fixedDeltaTime это фиксированное значение из настроек.","deltaTime и fixedDeltaTime всегда имеют одинаковое значение во время выполнения игры.","deltaTime это время между кадрами, а fixedDeltaTime это количество кадров за одну секунду.","deltaTime является статическим свойством класса Time в Unity, а fixedDeltaTime нет."],"CorrectAnswerIndex":0,"Explanation":"deltaTime представляет собой время (в секундах) между текущим и предыдущим кадрами. deltaTime может изменяться в зависимости от производительности системы, поэтому движение объектов может быть разным на разных устройствах.\nfixedDeltaTime представляет собой фиксированное значение времени между кадрами, которое задается в настройках проекта.fixedDeltaTime не меняется во время выполнения игры и обеспечивает стабильность физических эффектов и симуляций на разных устройствах.","Difficulty":20},{"Text":"Какое свойство компонента Rigidbody определяет, будет ли объект подвержен гравитации?","Answers":[" useGravity","mass"," isKinematic","velocity"],"CorrectAnswerIndex":0,"Explanation":"Свойство компонента Rigidbody, которое определяет гравитацию, называется \"useGravity\".\n\nЕсли значение свойства \"useGravity\" установлено в \"true\", объект будет подвержен гравитации и будет свободно падать под воздействием силы тяжести. Если значение установлено в \"false\", объект будет игнорировать гравитацию и не будет падать.","Difficulty":21},{"Text":"Какой компонент Unity3D используется для работы с пользовательским вводом, таким как клавиатура и мышь?","Answers":["Input","Collider","Rigidbody","Animator"],"CorrectAnswerIndex":0,"Explanation":"Input предоставляет статические методы для определения состояния клавиш клавиатуры, кнопок мыши и других устройств ввода. С помощью этого компонента вы можете обрабатывать ввод пользователя и реагировать на действия, такие как нажатие клавиш, перемещение мыши, события сенсорных экранов и др.","Difficulty":21},{"Text":"Что представляет собой компонент NavMeshAgent в Unity3D?","Answers":["Компонент для управления навигацией и перемещением объектов.","Компонент для управления освещением на сцене.","Компонент для работы с физическими эффектами.","Компонент для создания и управления анимациями персонажей."],"CorrectAnswerIndex":0,"Explanation":"Компонент NavMeshAgent в Unity3D представляет собой навигационный агент, который используется для управления движением объектов по навигационной сетке (NavMesh). Навигационная сетка представляет собой пространство, разбитое на маленькие ячейки, в которых определены доступные для движения области.\n\nКогда объекту добавляется компонент NavMeshAgent, он становится способным автоматически перемещаться по навигационной сетке, следуя определенным путям к заданным точкам. Это позволяет реализовать автоматическое управление движением персонажей или других объектов в игре.","Difficulty":22},{"Text":"Что такое var в C#?","Answers":["Ключевое слово, которое используется для объявления переменных с неявным типом.","Ключевое слово, которое используется для объявления переменной без инициализации.","Используется для создания переменных, содержащих только числовые значения.","Ключевое слово, которое указывает на переменную с динамическим типом данных."],"CorrectAnswerIndex":0,"Explanation":"В C#, ключевое слово var используется для объявления переменной без явного указания её типа. Вместо того, чтобы явно указывать тип переменной, компилятор C# самостоятельно определяет тип переменной на основе выражения, с которым переменная инициализируется.\nvar number = 10;\nvar name = \"John\";\nvar isValid = true;\nИспользование var упрощает и укорачивает код, особенно в случаях, когда тип переменной очевиден из контекста инициализации. Ключевое слово var особенно полезно при работе с анонимными типами, LINQ-запросами или сложными типами данных, когда точное указание типа может быть громоздким и неудобным.","Difficulty":23},{"Text":"Что такое модификаторы доступа?","Answers":["Ключевые слова, определяющие уровень видимости и доступности членов класса.","Это особые ключевые слова, которые позволяют изменять цвет и шрифт текста в коде, делая его более удобочитаемым.","Это специальные инструкции, которые позволяют включать и отключать определенные функции в коде.","Это специальные методы, которые используются для обработки исключений в программе."],"CorrectAnswerIndex":0,"Explanation":"Модификаторы доступа в языке программирования определяют уровень видимости и доступности членов класса . \npublic: Члены с модификатором public доступны из любого места программы, включая другие классы и пространства имен.\nprivate: Члены с модификатором private доступны только внутри того же класса, в котором они объявлены. \nprotected: Члены с модификатором protected доступны внутри того же класса и его производных классов. \ninternal: Члены с модификатором internal доступны внутри того же проекта (сборки). Они не видны из других проектов.","Difficulty":23},{"Text":"Какой компонент Unity3D используется для управления движением персонажа в игре?","Answers":["Character Controller","Collider","Light","Particle System"],"CorrectAnswerIndex":0,"Explanation":"Character Controller в Unity - это компонент, который предоставляет простой способ управления движением персонажа в 3D пространстве. Он обеспечивает базовое управление персонажем без использования физического движения Rigidbody, что делает его более подходящим для управления персонажами от первого или третьего лица, особенно в играх с ограниченным движением, например, в платформерах или RPG.\n\nCharacter Controller предоставляет методы для перемещения персонажа по поверхности, обработки столкновений с препятствиями и управления гравитацией.","Difficulty":24},{"Text":"Что такое draw call?","Answers":["Draw call  - это команда, отправляемая графическому процессору для отображения определенного объекта или группы объектов.","Draw call - это событие, которое происходит, когда игровой движок обновляет позиции и повороты объектов на экране.","Draw call - это специальный графический эффект, который придает трехмерным объектам в играх объемность и глубину.","Draw call - это процесс загрузки графических ресурсов, таких как текстуры и модели, в память компьютера."],"CorrectAnswerIndex":0,"Explanation":"Draw call (также известный как отрисовка, вызов отрисовки) - это операция, при которой графический движок или API (например, Unity, DirectX, OpenGL) рисует геометрию или объекты на экране. Draw call представляет собой команду, отправляемую процессору видеокарты для отрисовки графических элементов, таких как вершины, индексы, текстуры, материалы и шейдеры.\n\nКаждый draw call является отдельным запросом к видеокарте для отображения определенной графической информации. ","Difficulty":25},{"Text":"Что такое слои (layers) в Unity3D?","Answers":["Это способ разделения сложной сцены на отдельные части для управления отображением.","Это функция для группировки объектов на сцене.","Это компонент для управления источниками света.","Это текстура, применяемая к объектам на сцене."],"CorrectAnswerIndex":0,"Explanation":"В Unity3D слои (layers) представляют собой механизм, который позволяет классифицировать и группировать объекты на сцене. Каждый объект в Unity может быть помещен на один из 32 доступных слоев. Это позволяет управлять поведением объектов в зависимости от их слоя, осуществлять проверки столкновений с определенными слоями и управлять видимостью объектов на сцене.","Difficulty":25},{"Text":"Какой визуальный эффект удаляют ортографические камеры?","Answers":["Перспективу","Гамма-коррекцию цвета","Глубину резкости","Сияние "],"CorrectAnswerIndex":0,"Explanation":"Ортографическая камера в Unity - это тип камеры, который создает изометрическое или ортографическое проектирование сцены. В отличие от перспективной камеры, ортографическая камера не создает перспективное искажение и не учитывает расстояние до объектов. Все объекты на сцене отображаются в одинаковом масштабе, что делает этот тип камеры часто используемым для 2D игр или для создания изометрических проекций в 3D сценах.","Difficulty":26},{"Text":"Что такое partial классы?","Answers":["Partial-классы позволяют разделить определение класса между несколькими файлами.","Partial классы могут быть унаследованы только один раз и не могут быть расширены другими классами.","Partial классы позволяют объявлять статические методы и свойства, недоступные для экземпляров класса.","Partial классы используются для создания объектов с переменным числом свойств и методов."],"CorrectAnswerIndex":0,"Explanation":"Partial классы в C# позволяют определить класс в нескольких отдельных файлах. Каждый файл содержит часть определения класса, помеченную ключевым словом partial. Все эти части объединяются компилятором в один класс при компиляции.\nФайл1: \npublic partial class MyClass\n{\n    public void Method1()\n}\nФайл2: \npublic partial class MyClass\n{\n    public void Method2()\n}","Difficulty":27},{"Text":"Что такое сборка мусора (GC)?","Answers":["Это автоматический процесс управления памятью, который отслеживает и удаляет объекты, которые больше не используются.","Это автоматический процесс удаления мусора из системного диска для освобождения места.","Это процесс очистки памяти ОЗУ от данных, не используемых в данный момент программой.","Это процесс удаления неиспользуемых переменных из программы."],"CorrectAnswerIndex":0,"Explanation":"Сборка мусора (Garbage Collection, GC) - это автоматический процесс управления памятью в программах, который отслеживает и удаляет объекты, которые больше не используются и стали недоступны для программы.\n\nВ языках программирования с автоматическим управлением памятью, таких как C# или Java, программисту не требуется явно освобождать память, выделенную для объектов. Вместо этого сборщик мусора отслеживает, какие объекты не имеют ссылок на них из программы, и периодически освобождает память, занятую этими объектами.\n\nСборка мусора позволяет избежать утечек памяти и упрощает процесс управления памятью.","Difficulty":27},{"Text":"Что такое API?","Answers":["API - это набор правил и инструкций, определяющих, как различные компоненты могут взаимодействовать друг с другом.","API - это методика шифрования данных, используемая для обеспечения безопасности в сети Интернет.","API - это метод разработки автоматических систем для создания сложных систем веб-сайтов.","API - это устройство для подключения к компьютеру и ввода команд с помощью голоса."],"CorrectAnswerIndex":0,"Explanation":"API (Application Programming Interface) - это набор правил и протоколов, которые определяют, как различные компоненты программного обеспечения взаимодействуют друг с другом. Он предоставляет набор функций, процедур, классов и структур, которые программисты могут использовать для создания приложений или интеграции различных систем.\nПримером API может быть OpenWeatherMap API, где мы можем использовать API-ключ и отправить запрос для получения данных о погоде. Результатом будет ответ в формате JSON или XML с информацией о погоде для заданного города или местоположения.","Difficulty":28},{"Text":"Что такое Boxing/Unboxing в C#?","Answers":["Boxing и Unboxing - это процессы преобразования значимых типов данных в ссылочные типы и обратно. ","Boxing и Unboxing - это специальные методы, используемые для сериализации и десериализации объектов в C#.","Boxing и Unboxing - это механизмы, которые позволяют создавать анонимные типы и работать с ними в C#.","Boxing и Unboxing - это способы управления памятью и освобождения ресурсов в C#."],"CorrectAnswerIndex":0,"Explanation":"Boxing - это процесс преобразования значимого типа данных в экземпляр объекта соответствующего ссылочного типа. При упаковке (boxing) значение переменной копируется в новый объект-контейнер на куче, а переменная становится ссылкой на этот объект. \nint number = 42;\nobject boxedNumber = number;\nUnboxing - это процесс извлечения значения из упакованного объекта и преобразования его обратно в исходный значимый тип данных. При распаковке (unboxing) значение извлекается из объекта-контейнера и преобразуется в исходный тип данных.\nobject boxedNumber = 42;\nint number = (int)boxedNumber;\n","Difficulty":29},{"Text":"\nЧто такое дженерики?","Answers":["Дженерики - это механизм, позволяющий создавать обобщенные типы, методы и классы.","Дженерики - это способ использования методов, которые автоматически определяют типы данных во время выполнения программы.","Дженерики - это механизм для работы с текстовыми данными.","Дженерики - это набор заранее определенных обобщенных классов и методов, которые можно использовать в языке C#."],"CorrectAnswerIndex":0,"Explanation":"Дженерики (Generics) в C# представляют механизм, который позволяет создавать обобщенные типы, классы и методы, которые могут работать с различными типами данных. Это позволяет повторно использовать код и обеспечивает безопасность типов на этапе компиляции.\npublic static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\nВ данном примере метод Swap является обобщенным, так как определен с параметром типа T. ","Difficulty":29},{"Text":"Где доступны члены с модификатором private?","Answers":["Только внутри того же класса, в котором они объявлены.","Внутри того же проекта (сборки).","Внутри того же класса и его производных классов (наследников).","Из любого места программы, включая другие классы и пространства имен."],"CorrectAnswerIndex":0,"Explanation":"Члены с модификатором private доступны только внутри того же класса, в котором они объявлены. Это означает, что члены с модификатором private недоступны из других классов, даже если эти классы находятся в той же сборке.","Difficulty":30},{"Text":"Зачем нужны отдельные Update и FixedUpdate?","Answers":["Update используют, где важна зависимость от времени, FixedUpdate - где важна независимость от FPS.","Update предназначен для физических расчетов, а FixedUpdate - для анимации и пользовательского ввода.","Update работает в отдельном потоке от FixedUpdate.","Update и FixedUpdate делают одно и то же, но обрабатываются в произвольной последовательности."],"CorrectAnswerIndex":0,"Explanation":"Отделение логики обновления на Update и FixedUpdate помогает более точно контролировать обновление объектов. Это особенно важно для физических расчетов и других операций, которые должны происходить с постоянной частотой.\nUpdate: вызывается на каждом кадре рендеринга и используется для обновления логики, которая зависит от времени (пользовательский ввод, движение объектов, анимации).\n\nFixedUpdate: вызывается с фиксированной частотой(0.02 сек). Он предназначен для обработки физических расчетов и других операций, которые должны выполняться с постоянной частотой независимо от FPS игры.","Difficulty":31},{"Text":"Чтобы вызвалось событие OnTriggerEnter при столкновении двух объектов, какие два компонента обязательно должны быть на этих объектах?","Answers":["Rigidbody и Collider","Collider и MeshRenderer","Collider и MeshFilter","MeshRenderer и MeshFilter"],"CorrectAnswerIndex":0,"Explanation":"Компонент Rigidbody используется для добавления физических свойств объекту, позволяя ему взаимодействовать с физическим миром, подвергаться силам, гравитации и имитировать реалистичные движения.\n\nКомпонент Collider определяет границы и форму объекта, позволяя ему взаимодействовать с другими объектами через столкновения и коллизии. Collider также используется для обработки физического взаимодействия с окружающими объектами и другими физическими телами в сцене.","Difficulty":31},{"Text":"Что такое Coroutines в Unity? ","Answers":["Механизм, который позволяет создавать асинхронные операции и управлять временем выполнения задач в игре.","Механизм, позволяющий выполнять длительные операции без влияния на производительность игры.","Механизм, применяемый для асинхронной обработки пользовательского ввода.","Механизм, который используется для синхронного выполнения кода без задержек."],"CorrectAnswerIndex":0,"Explanation":"Coroutines в Unity - это механизм, который позволяет создавать асинхронные операции и управлять временем выполнения задач в игре. Они позволяют выполнять отложенные действия или анимации без блокировки основного потока выполнения, что облегчает выполнение сложных задач, таких как анимации, переходы между сценами и другие длительные операции.\n\nРабота с Coroutines происходит с помощью ключевого слова yield, которое позволяет приостанавливать выполнение функции и возобновлять его позднее.","Difficulty":32},{"Text":"В каком порядке вызываются методы жизненного цикла MonoBehaviour, начиная с инициализации объекта до его уничтожения?","Answers":["Awake, Start, FixedUpdate, Update, LateUpdate, OnDestroy","Awake, Start, Update, FixedUpdate, LateUpdate, OnDestroy","Start, Awake, Update, LateUpdate, FixedUpdate, OnDestroy"," Start, Awake, FixedUpdate, LateUpdate, Update, OnDestroy"],"CorrectAnswerIndex":0,"Explanation":"Awake() -  для инициализации переменных и компонентов объекта.\nStart() - для запуска процессов, которые зависят от других объектов.\nFixedUpdate() -  для работы с физикой и перемещения объектов.\nUpdate() -   для обновления логики объекта и обработки пользовательского ввода.\nLateUpdate() -  для выполнения логики, которая зависит от обновления других объектов.\nOnDestroy() - вызывается перед уничтожением объекта. Используется для освобождения ресурсов и очистки памяти.","Difficulty":33},{"Text":"Что такое Cinemachine в Unity?","Answers":["Это пакет инструментов для создания сложных камерных движений и управления камерами в игре. ","Это специальный редактор для создания анимированных камерных эффектов.","Это библиотека для создания трехмерных моделей и анимаций в Unity.","Это компонент для отображения анимированных эффектов на сцене."],"CorrectAnswerIndex":0,"Explanation":"Cinemachine - это пакет для Unity, который предоставляет удобные инструменты для создания сложных камерных систем. Он позволяет легко настраивать и контролировать камеры в игре, добавлять эффекты переходов между камерами, управлять камерой в режиме реального времени и создавать динамические камерные треки. Cinemachine упрощает процесс создания кинематографических камерных эффектов и обеспечивает более гибкий и эффективный подход к управлению камерами в игровом проекте.","Difficulty":33},{"Text":"Какой атрибут C# отображает private переменную в инспекторе объектов?","Answers":[" SerializedField","Serializable"," HideInInspector"," Range"],"CorrectAnswerIndex":0,"Explanation":"Атрибут SerializedField используется в Unity для отображения и редактирования приватных или защищенных переменных в инспекторе редактора, делая их доступными для редактирования без необходимости делать их публичными. Таким образом, можно сохранить инкапсуляцию и одновременно предоставить возможность редактирования значений в инспекторе без доступа к ним извне класса.","Difficulty":34},{"Text":"Сколько по времени по умолчанию занимает FixedUpdate?","Answers":["0.02 секунды","Время зависит от сложности логики, которую вы выполняете в этом методе.","1 миллисекунду","один кадр времени (1/60 секунды на 60 FPS)."],"CorrectAnswerIndex":0,"Explanation":"FixedUpdate вызывается с фиксированной частотой, которая по умолчанию равна 50 раз в секунду (каждые 0.02 секунды). Однако это значение может быть изменено в настройках проекта.","Difficulty":35},{"Text":"Что такое Raycast в Unity3D и для чего он используется?","Answers":["Это метод для проверки столкновения луча с объектами на сцене.","Это компонент для обработки пользовательского ввода.","Это метод для установки камеры на сцене.","Это компонент для создания луча света на сцене."],"CorrectAnswerIndex":0,"Explanation":"Raycast - это метод, используемый для определения столкновений луча (ray) с объектами в сцене. Луч представляет собой виртуальный луч света, который исходит из начальной точки и направлен в определенном направлении. Raycast проверяет, пересекается ли этот луч с какими-либо коллайдерами в сцене и возвращает информацию о первом объекте, с которым происходит столкновение.","Difficulty":35},{"Text":"Что делает атрибут Range?","Answers":["Ограничивает значение переменной с помощью ползунка.","Он проверяет значения переменных через виджет текстового поля.","Он ограничивает значения переменных с помощью виджета выбора цвета.","Он представляет допустимые варианты переменной в раскрывающемся списке."],"CorrectAnswerIndex":0,"Explanation":"Атрибут [Range(min, max)] в Unity используется для ограничения диапазона значений числовых полей (например, float или int) в инспекторе. Он позволяет задать минимальное и максимальное значение, которое может принимать данное числовое поле.\n\nПрименение атрибута [Range] к числовому полю позволяет разработчику установить ограничение значений в инспекторе редактора Unity, чтобы предотвратить ввод недопустимых или неправильных значений для данного поля.","Difficulty":36},{"Text":"Кому доступны переменные с модификатором protected на уровне класса?","Answers":["Доступны самому классу и его производным классам (наследникам) ","Доступны только внутри класса, где они объявлены.","Доступны только в классах, находящихся в том же пространстве имен, что и класс, где они объявлены.","Доступны только в классах, находящихся в том же файле исходного кода, что и класс, где они объявлены."],"CorrectAnswerIndex":0,"Explanation":"Переменные с модификатором protected на уровне класса доступны самому классу, производным классам (наследникам) и любым другим классам в той же самой сборке (assembly).","Difficulty":37},{"Text":"Что делает аттрибут [Space(20)]?","Answers":["Он делает отступ 20 пикселей над переменной внутри инспектора объектов.","Он вставляет 20 знаков пробела в качестве значения по умолчанию.","Он вставляет 20 пикселей слева и справа от переменной в инспекторе.","Он ограничивает количество знаков пробела в 20 символов."],"CorrectAnswerIndex":0,"Explanation":"Атрибут [Space(X)] используется в Unity для добавления вертикального пространства (отступа) между сериализованными полями в инспекторе. В скобках указывается значение, которое определяет количество пикселей отступа.\n\nНапример, если у нас есть несколько сериализованных полей в MonoBehaviour-скрипте, и мы хотим добавить большой вертикальный отступ между ними в инспекторе, мы можем применить атрибут [Space(20)] перед полем, которое должно быть разделено от других.","Difficulty":37},{"Text":"Может ли класс реализовать два интерфейса, у которых объявлены одинаковые методы?","Answers":["Класс может реализовать два интерфейса с одинаковыми методами, но нужно указать принадлежность каждого метода.","Класс может реализовать два интерфейса с одинаковыми методами, но их реализация должна быть одинаковой.","При вызове метода будет использоваться реализация только первого интерфейса.","Класс не может реализовать два интерфейса с одинаковыми методами, так как это вызывает конфликт в имени метода."],"CorrectAnswerIndex":0,"Explanation":"Когда класс реализует два интерфейса с одинаковыми методами, он должен явно указать, какой метод относится к какому интерфейсу, чтобы избежать неоднозначности. Это делается путем использования полной квалификации имени метода, указывающей на соответствующий интерфейс:\n((IInterface1)myObj).MyMethod();   // Вызов MyMethod из IInterface1\n((IInterface2)myObj).MyMethod();  // Вызов MyMethod из IInterface2","Difficulty":38},{"Text":"Что такое draw call в Unity?","Answers":["Это команда для отображения объектов на экране, которая содержит информацию о параметрах объекта. ","Это часть процесса рендеринга, которая отвечает за расчет освещения.","Это процесс обработки физического взаимодействия между объектами в Unity.","Это способ определения, какие объекты должны быть отображены на экране."],"CorrectAnswerIndex":0,"Explanation":"Draw call (отрисовка) в Unity - это процесс отправки графических команд на отрисовку объектов на экране. Каждый раз, когда Unity отрисовывает объекты на сцене, он генерирует draw call для каждого объекта или набора объектов с одинаковыми материалами и настройками отображения.\n\nDraw call содержит информацию о том, какой объект отрисовать, какой материал использовать, его позицию, поворот и масштаб, а также другие настройки, такие как режимы смешивания, отключение или включение затенения, маскировка и т. д.","Difficulty":39},{"Text":"Что делает этот код:\nFloat Answer = Random.value * 10f;","Answers":["Выбирает случайное значение между 0 и 10","Выбирает случайное значение больше 10","Выбирает случайное значение меньше 10","Выбирает случайное значение кратное 10"],"CorrectAnswerIndex":0,"Explanation":"Random.value возвращает случайное значение с плавающей точкой в диапазоне от 0.0 (включительно) до 1.0 (исключительно). Таким образом, это функция, которая генерирует случайное число с плавающей точкой от 0 до 1.","Difficulty":39},{"Text":"Что такое инкапсуляция (1 принцип ООП)?","Answers":["Сокрытие деталей реализации объектов и предоставление интерфейса для работы с ними.","Процесс превращения объекта в капсулу, которая может быть использована для хранения других объектов.","Способность объекта взаимодействовать только с объектами своего класса.","Принцип, который запрещает использование публичных методов и полей в классе."],"CorrectAnswerIndex":0,"Explanation":"Инкапсуляция (Encapsulation) - это первый принцип ООП, который заключается в объединении данных и методов, работающих с этими данными, в единый объект (класс), и предоставлении доступа к ним только через интерфейс (публичные методы) этого объекта. Суть инкапсуляции состоит в том, что внутреннее состояние объекта остается скрытым от внешнего кода, и изменения данных объекта производятся только через установленные методы.\nГлавная цель инкапсуляции - обеспечить контроль над доступом к данным и методам объекта, предоставляя защищенный интерфейс для работы с объектом. ","Difficulty":40},{"Text":"Какое утверждение не соответствует действительности?","Answers":["Только у гуманоидных персонажей есть кости.","Функция обновления никогда не вызывается автоматически, пока объект не активен.","Корутины будут продолжать работать на неактивных объектах.","Все скрипты компонентов наследуются от MonoBehaviour."],"CorrectAnswerIndex":0,"Explanation":"Кости (bones) обычно используются в анимации персонажей или объектов для управления их движением. В компьютерной графике и 3D-моделировании кости представляют собой невидимые точки или сущности, которые используются для создания иерархической структуры, описывающей и управляющей движением модели.","Difficulty":41},{"Text":"Что такое графическая библиотека (OpenGL, DirectX)?","Answers":["Графическая библиотека это набор инструментов и функций, для управления графикой и визуальными эффектами.","Графическая библиотека это набор физических компонентов, которые подключаются для улучшения графического вывода.","Графическая библиотека это программное обеспечение для создания и редактирования фотографий и изображений.","Графическая библиотека это система, которая управляет размещением и отображением графических элементов на веб-сайтах."],"CorrectAnswerIndex":0,"Explanation":"Графическая библиотека, такая как OpenGL или DirectX, представляет собой набор программных интерфейсов и функций, которые разработчики могут использовать для создания и управления графикой в приложениях. Они обеспечивают доступ к низкоуровневым операциям рендеринга и взаимодействию с видеокартой. \nПример: команда на C++  \"pDeviceContext->ClearRenderTargetView(pRenderTargetView, DirectX::Colors::SteelBlue);\"  указывает устройству DirectX очистить буфер заднего фона и заполнить его указанным цветом перед началом отрисовки нового кадра. ","Difficulty":41},{"Text":"В чем состоит \"Принцип единственной ответственности\" (1 принцип SOLID)?","Answers":["Класс должен быть ответственным только за одну функциональность или задачу.","Принцип требует, чтобы каждый метод в классе выполнял только одну задачу.","Класс должен выполнять одну операцию за раз, а все остальные операции должны быть отложены.","Каждый класс должен быть максимально полезным и включать как можно больше функциональности."],"CorrectAnswerIndex":0,"Explanation":"Принцип единственной ответственности означает, что каждый класс должен иметь только одну причину для изменения. Иными словами, класс должен быть ответственным только за одну четко определенную функциональность или задачу.\n\nСуть этого принципа заключается в том, чтобы разделить разные функциональности на различные классы. Это уменьшает сложность классов, делает их более понятными и улучшает поддерживаемость программного кода. Когда класс выполняет несколько независимых задач, изменения в одной задаче могут повлиять на другие, что усложняет понимание и поддержку кода.","Difficulty":42},{"Text":"Что такое Unity Package Manager (UPM)?","Answers":["Это инструмент для  установки и управления пакетами, а также их зависимостей в проекте Unity.","Это специальный компонент для создания упакованных файлов сцен, моделей и ассетов в Unity.","Это инструмент для резервного копирования и восстановления проектов Unity.","Это инструмент для обмена ресурсами и кодом между разными проектами Unity."],"CorrectAnswerIndex":0,"Explanation":"Unity Package Manager (UPM) - это инструмент в Unity, который обеспечивает управление и установку пакетов, а также их зависимостей в проекте Unity. Он позволяет разработчикам легко добавлять сторонние пакеты в свои проекты, а также управлять версиями и обновлениями этих пакетов.\n\nUPM предоставляет удобный интерфейс для поиска, установки и удаления пакетов из Unity Asset Store, репозиториев Git или локальных путей. Он также автоматически разрешает зависимости между пакетами, что позволяет легко подключать сторонние библиотеки и инструменты к проекту.","Difficulty":43},{"Text":"Что такое Procedural Generation в Unity?","Answers":["Техника для генерации контента в игре, такого как уровни, миры или текстуры.","Метод для генерации случайных чисел в игровом процессе.","Алгоритм для оптимизации работы с анимациями персонажей.","Механизм для создания случайных столкновений между объектами в сцене."],"CorrectAnswerIndex":0,"Explanation":"Procedural Generation (процедурная генерация) в Unity - это метод создания контента, такого как уровни, миры, текстуры, модели, анимации и другие элементы, с использованием алгоритмов и случайных чисел, вместо традиционного ручного создания каждого элемента.\n\nПроцедурная генерация позволяет разработчикам автоматизировать и упростить процесс создания большого объема контента, что особенно полезно для создания крупных открытых миров или повторяющихся элементов в игре. ","Difficulty":43},{"Text":"Элементы пользовательского интерфейса, такие как изображения и кнопки, могут быть зафиксированы в определенных позициях экрана для создания адаптивных интерфейсов. Какие функции Unity помогают достичь этого?","Answers":["Якоря и оси(Anchors, pivots)","События и рейкасты(Events, raycasts)","Кватернионы и углы Эйлера(Quaternions, Euler angles)","Непрозрачность и прозрачность(Opacity, transparency)"],"CorrectAnswerIndex":0,"Explanation":"Якоря (Anchors) и оси (Pivots) в Unity используются для управления расположением и масштабированием UI-элементов и спрайтов.\n\nЯкоря (Anchors): Якоря определяют, как элементы будут растягиваться и масштабироваться при изменении размеров родительского элемента или экрана. Установка якорей позволяет автоматически подстраивать элементы под разные разрешения экрана или размеры родительского контейнера.\n\nОси (Pivots): Оси определяют точку вокруг которой происходит вращение и масштабирование объекта. Установка осей позволяет управлять точкой вращения и масштабирования, что полезно для анимации и позиционирования объектов.","Difficulty":44},{"Text":"Где доступны члены с модификатором  protected?","Answers":["Внутри того же класса и его производных классов (наследников).","Внутри того же проекта (сборки).","Из любого места программы, включая другие классы и пространства имен.","Только внутри того же класса, в котором они объявлены."],"CorrectAnswerIndex":0,"Explanation":"Члены с модификатором protected доступны внутри того же класса и его производных классов (наследников), но не доступны из других классов вне иерархии наследования.","Difficulty":45},{"Text":"Какая разница между перегрузкой и переопределением методов?","Answers":["Перегрузка методов - это изменение сигнатуры метода, а переопределение методов - изменение его реализации.","Перегрузка методов - это изменение реализации метода, а переопределение методов - изменение его сигнатуры.","Перегрузка используется в статическом полиморфизме, а переопределение методов - только в динамическом.","Перегрузка методов используется для изменения видимости метода, а переопределение - для изменения доступности."],"CorrectAnswerIndex":0,"Explanation":" Перегрузка методов относится к созданию нескольких методов с одним и тем же именем, но с разными параметрами. Переопределение методов происходит, когда производный класс изменяет реализацию метода, унаследованного от базового класса.","Difficulty":45},{"Text":"Что такое абстракция (4 принцип ООП)?","Answers":["Представление объектов программы в упрощенной форме, отделяя важные характеристики от ненужных деталей.","Это возможность использовать абстрактные классы для создания объектов.","Это возможность использовать абстрактные поля и методы в классе.","Это принцип ООП, который требует, чтобы все классы в программе были абстрактными."],"CorrectAnswerIndex":0,"Explanation":"Абстракция (Abstraction) - принцип ООП, который заключается в представлении объектов программы в упрощенной форме, скрывая детали реализации и выделяя только существенные характеристики и функциональность.\n\nОсновная цель абстракции состоит в том, чтобы предоставить понятный и удобный интерфейс для взаимодействия с объектами, скрывая сложные детали и делая код более понятным и удобочитаемым. Абстракция позволяет абстрагироваться от внутренних деталей реализации и сосредоточиться на важных аспектах объекта.","Difficulty":46},{"Text":"Какой метод в MonoBehaviour вызывается каждый раз перед отрисовкой кадра и используется для обновления графических элементов?","Answers":["Update","OnRenderObject","FixedUpdate","Start"],"CorrectAnswerIndex":0,"Explanation":"Метод Update() в классе MonoBehaviour вызывается каждый раз перед отрисовкой кадра. Он используется для обновления графических элементов и других компонентов игровых объектов. В Update() можно выполнять логику обновления, перемещения, анимации и других действий, которые должны происходить на каждом кадре игры.","Difficulty":47},{"Text":"Когда стоит использовать StringBuilder вместо string?","Answers":["StringBuilder используют, когда нужно часто конкатенировать или модифицировать строки.","Это одно и то же, string - сокращенная записть от StringBuilder.","StringBuilder следует использовать, когда вам нужно выполнить операции форматирования строки.","StringBuilder применяется только в случае, если вы хотите работать с небольшими строками."],"CorrectAnswerIndex":0,"Explanation":"String является неизменяемым типом данных, что означает, что после создания строки ее нельзя изменить. Все операции над строками, такие как конкатенация или замена символов, фактически создают новые строки в памяти. \nВ то время как StringBuilder является изменяемым типом данных, который позволяет изменять содержимое строки без создания новых объектов. Внутреннее представление StringBuilder в C# базируется на массиве символов (char[]). ","Difficulty":47},{"Text":"Что такое наследование (2 принцип ООП)?","Answers":["Возможность создания новых классов на основе существующих, наследуя их свойства и методы.","Возможность создания объектов из абстрактных классов.","Возможность класса включать в себя все свойства и методы другого класса.","Это принцип, который позволяет классам наследовать только статические методы."],"CorrectAnswerIndex":0,"Explanation":"Наследование (Inheritance) - позволяет создавать новые классы на основе существующих (родительских) классов, наследуя их свойства и методы.\nПринцип наследования позволяет повторно использовать код, который уже был реализован в базовом классе, что способствует уменьшению дублирования кода и улучшает структурированность программы. При этом производный класс может добавлять свою уникальную функциональность или переопределять поведение методов базового класса.","Difficulty":48},{"Text":"С помощью какой арифметической операции можно комбинировать кватернионы?","Answers":["Умножение","Деление","Сложение","Вычитание"],"CorrectAnswerIndex":0,"Explanation":"Для комбинирования кватернионов в Unity используется операция умножения (*).\n\nНапример, если у нас есть два кватерниона quat1 и quat2, мы можем комбинировать их следующим образом:\nQuaternion combinedQuaternion = quat1 * quat2;","Difficulty":49},{"Text":"Чем принципиально отличается фреймворк от библиотеки?","Answers":["Фреймворк предоставляет архитектуру и правила разработки. Библиотека - набор утилит и функций для решения конкретных задач.","Фреймворк  предоставляет низкоуровневую функциональность. Библитека - высокоуровневую.","Фреймворк это набор утилит и инструментов. Библиотека - набор функций.","Фреймворк - это набор шаблонов проектирования. Библиотека - это набор различной документации проекта. "],"CorrectAnswerIndex":0,"Explanation":"Библиотека - это набор предварительно написанного кода, который используется для упрощения задач. Библиотеки заточены на узкие цели. Напримет Zenject, Newtonsoft.Json, Unity UI. \n\nФреймворк - это полный набор низкоуровневых библиотек, который позволяет пользователю создавать приложения. Он управляет всеми вызовами библиотеки и, отвечает за поток функций. Фреймворк подобен фундаменту, на котором разработчики создают приложения для определённых платформ. Пример фреймворков: Cinemachine, ProBuilder, Unity Input System. Сама Unity является фреймворком.\n\nМы в коде используем библиотеку, фреймворк использует наш код. \n","Difficulty":49},{"Text":"Неявное приведение типа это:","Answers":["int i = 10; double d = i;","double d = 10.5; int i = (int)d;","string str = \"10\"; int i = int.Parse(str);","double d = 10.5; int i = Convert.ToInt32(d);"],"CorrectAnswerIndex":0,"Explanation":"Неявное приведение типа (implicit type casting) в C# - это автоматическая операция преобразования значения из одного типа в другой без явного указания со стороны разработчика. В случае неявного приведения типа, компилятор самостоятельно выполняет преобразование, если оно безопасно и не приведет к потере данных или искажению значения.","Difficulty":50},{"Text":"Наследуются ли переменные с модификатором private при наследовании класса?","Answers":["Нет.","Да, они доступны в производном классе.","Могут быть унаследованы только в случае, если производный класс объявлен в том же файле, что и базовый класс.","Возможно только при использовании специального ключевого слова inherit."],"CorrectAnswerIndex":0,"Explanation":"Модификатор private делает переменные доступными только в пределах того класса, в котором они объявлены, и не позволяет их доступ к другим классам, включая производные классы.\n\nКогда класс наследует другой класс, он может получить доступ только к публичным и защищенным (protected) членам базового класса. Приватные (private) переменные, методы или другие члены класса остаются недоступными для наследующего класса.","Difficulty":51},{"Text":"Что такое ECS?","Answers":["Парадигма разработки ПО, разделяющая сущности, компоненты и системы.","Это группа инициалов известных личностей, работающих в игровой индустрии.","Это язык программирования, разработанный для работы с квантовыми компьютерами.","Это сокращение для \"Eternal Creative System\", философия о творческом подходе в работе."],"CorrectAnswerIndex":0,"Explanation":"ECS (Entity-Component-System) - это парадигма разработки программного обеспечения, широко используемая в разработке компьютерных игр. ECS представляет собой архитектурный подход, который помогает разделить логику и данные компонентов, улучшая производительность и упрощая разработку сложных систем.\n\nОсновные компоненты ECS:\n\nEntity (сущность): Представляет игровой объект или объект в системе. \n\nComponent (компонент): Компоненты - это контейнеры для данных, представляющих конкретные аспекты сущности.\n\nSystem (система): Системы обрабатывают компоненты сущностей и реализуют логику игры или поведения.","Difficulty":52},{"Text":"Что делает функция Destroy?","Answers":["Удаляет указанный игровой объект после текущего цикла обновления.","Удаляет указанный игровой объект, когда приложение завершит работу.","Немедленно удаляет указанный игровой объект.","Немедленно деактивирует указанный игровой объект."],"CorrectAnswerIndex":0,"Explanation":"Функция Destroy в Unity используется для уничтожения объектов во время выполнения игры.\n\nКогда вызывается метод Destroy, он помечает объект для уничтожения. Однако само уничтожение объекта происходит не сразу, а в конце текущего кадра или на следующем кадре. Это означает, что объект продолжит существовать и выполнять свои методы до окончания текущего кадра, и только после этого будет удален из сцены и из памяти.\n Destroy(objectToDestroy);","Difficulty":52},{"Text":"Что такое конечная переменная?","Answers":["Переменная-константа с ключевым словом readonly.","Переменная с ключевым словом final.","Переменная, которая может быть объявлена только с конкретным типом данных.","Переменная, которая может быть объявлена без  инициализации."],"CorrectAnswerIndex":0,"Explanation":"Конечная переменная (final variable) - это переменная, значение которой не может быть изменено после ее инициализации. В других языках программирования такая переменная может называться \"константой\" или \"immutable переменной\".\n\nВ языке C#, ключевое слово для создания конечных переменных - readonly. После объявления и инициализации конечной переменной в конструкторе или при объявлении, ее значение не может быть изменено в дальнейшем. Это позволяет обеспечить безопасность и надежность программы, так как гарантируется, что значение переменной останется неизменным после инициализации.","Difficulty":53},{"Text":"Что такое Unity Collab и для чего он используется?","Answers":["Это инструмент совместной разработки и управления версиями.","Это компонент для работы с коллизиями и столкновениями объектов на сцене.","Это фреймворк для создания многопользовательских игр.","Это социальная сеть разработчиков Unity3D."],"CorrectAnswerIndex":0,"Explanation":"Unity Collab (ранее известный как Unity Teams) - это инструмент совместной разработки и управления версиями, предоставляемый Unity Technologies. Он используется для упрощения совместной работы над проектами в Unity3D, облегчения управления изменениями и версиями проекта, а также для обеспечения более безопасной и устойчивой разработки.\n\nОсновные функциональности:\nуправление версиями,\nсовместная разработка,\nконтроль доступа,\nоблачное хранилище.","Difficulty":54},{"Text":"Каким образом можно загрузить новый уровень в Unity3D?","Answers":["С помощью метода LoadScene","Изменением значения переменной level в коде","Копированием файла с уровнем в папку Assets","Нажатием кнопки \"New Level\" на панели инструментов"],"CorrectAnswerIndex":0,"Explanation":"Метод SceneManager.LoadScene()  позволяет загрузить новый уровень из сцены. Вы можете передать ему имя или индекс уровня, который нужно загрузить. \n// Загрузить уровень с именем \"Level2\"\nSceneManager.LoadScene(\"Level2\");","Difficulty":54},{"Text":"Какой метод MonoBehaviour выполняется по умолчанию в режиме редактора (Editor mode)?","Answers":["Reset","OnBecameInvisible","OnAnimatorMove","OnTriggerEnter"],"CorrectAnswerIndex":0,"Explanation":"Метод Reset — это метод MonoBehaviour, который по умолчанию запускается в режиме редактора. Этот метод вызывается, когда скрипт прикрепляется к GameObject или сбрасывается в Инспекторе. Он позволяет инициализировать или сбрасывать значения переменных в скрипте, обеспечивая согласованное начальное состояние при работе в редакторе Unity.","Difficulty":55},{"Text":"В чем различие между классом и структурой?","Answers":["Классы поддерживают наследование, структуры нет. Объекты класса передаются по ссылке, структуры - по значению.","Классы могут содержать методы, а структуры - только поля.","Классы нужно инициализировать с помощью ключевого слова \"new\", структуры не нужно.","Классы наследуют другие классы, а структуры только другие структуры."],"CorrectAnswerIndex":0,"Explanation":"Классы поддерживают наследование. Структуры не поддерживают. Объекты класса передаются по ссылке, изменения, внесенные в один объект, могут повлиять на другие объекты, которые ссылаются на тот же экземпляр. Структуры передаются по значению, каждый экземпляр структуры содержит свою собственную копию данных.\nОбъекты класса хранятся в куче (heap). Структуры хранятся в стеке (stack) или в куче.\nПоля класса могут иметь значение \"null\", если они не инициализированы. Поля структуры всегда должны иметь значение.\nВ общем случае, работа со структурами может быть более эффективной по производительности.","Difficulty":56},{"Text":"Когда автоматически вызывается метод Reset?","Answers":["При добавлении компонента к объекту или сбросе его значений в режиме редактирования.","Когда игровой объект перемещается из одной сцены в другую.","Когда сцена стартует или перезапускается.","Когда сцена стартует или перезапускается для деактивированного игрового объекта."],"CorrectAnswerIndex":0,"Explanation":"Метод Reset() автоматически вызывается в Unity для компонентов, когда они добавляются на объект или сбрасываются в значения по умолчанию. Это происходит в следующих случаях:\n\nПри добавлении компонента на объект в сцене или в префабе.\nПри сбросе компонента до значений по умолчанию, что можно сделать через контекстное меню компонента или кнопку \"Reset\" в инспекторе компонента.","Difficulty":56},{"Text":"Явное приведение типа это:","Answers":["double d = 10.5; int i = (int)d;","int i = 10; double d = i;","string str = \"10\"; int i = int.Parse(str);","double d = 10.5; int i = Convert.ToInt32(d);"],"CorrectAnswerIndex":0,"Explanation":"Явное приведение типа (explicit type casting) в C# - это операция, которая позволяет явно изменить тип значения из одного типа в другой. При явном приведении типа разработчик явно указывает, что хочет преобразовать значение из одного типа в другой, даже если такое преобразование потенциально может привести к потере данных или искажению значения.\n\nЯвное приведение типа выполняется с помощью оператора приведения (type)expression, где type - тип, в который нужно привести значение, а expression - выражение, которое нужно привести к указанному типу.","Difficulty":57},{"Text":"В чем состоит \"Принцип открытости/закрытости\" (2 принцип SOLID)?","Answers":["Классы и модули должны быть открыты для расширения, но закрыты для модификации.","Изменение метода в классе не должно влиять на другие методы в том же классе.","Классы должны быть открыты для изменений, чтобы обеспечить легкость модификации кода.","Все методы в классе должны быть открыты для переопределения в наследниках, а поля - закрыты."],"CorrectAnswerIndex":0,"Explanation":"Принцип открытости/закрытости из SOLID заключается в следующем:\n\"Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.\"\nЭто означает, что код должен быть написан таким образом, чтобы добавление новой функциональности не требовало изменения уже существующего кода. Новые возможности должны добавляться через расширение, используя наследование, интерфейсы, композицию и другие техники, не нарушая работу существующих компонентов.","Difficulty":58},{"Text":"Что такое полиморфизм (3 принцип ООП)?","Answers":["Возможность объектов одного класса использоваться как объекты другого класса с помощью общего интерфейса.","Это возможность создания объектов разных классов из одного абстрактного класса.","Способность объектов взаимодействовать только с объектами своего типа.","Возможность использовать один и тот же объект для разных целей в программе."],"CorrectAnswerIndex":0,"Explanation":"В основе полиморфизма лежит идея, что объекты, имеющие общий интерфейс (например, общие методы), могут быть использованы согласно этому интерфейсу, независимо от их фактического типа. Это позволяет передавать объекты производных классов туда, где ожидается объект базового класса, и вызывать методы наследников, не зная их конкретного типа.","Difficulty":58},{"Text":"В каком формате сохраняет аудиоданные класс Microphone?","Answers":["Audio clip asset","MP3 file","WAV file","OGG file"],"CorrectAnswerIndex":0,"Explanation":"Класс Microphone используется для доступа к микрофону компьютера или мобильного устройства и записи аудио с него. Он позволяет разработчикам создавать приложения, которые могут взаимодействовать с микрофоном, записывать звук, а также анализировать или воспроизводить аудиоданные в реальном времени. Это может быть полезно для создания голосового управления, аудио-игр или аудиоанализа в приложениях и играх.","Difficulty":59},{"Text":"Некоторые типы материалов включают в себя карты нормалей. Зачем нужна карта нормалей?","Answers":["Она создает детализацию поверхности на меше: неровности, вмятины и царапины.","Это система детализации, которая постепенно уменьшает количество полигонов по мере того, как камера удаляется.","Она заменяет геометрию для создания высокополигональных объектов.","Она программно уменьшает количество полигонов в мешах."],"CorrectAnswerIndex":0,"Explanation":"Карта нормалей (Normal Map) в компьютерной графике используется для придания плоским или низкополигональным моделям визуального впечатления детализации и объемности. Она является одним из важных типов текстурных карт, используемых в рендеринге 3D-моделей.\n\nВ игровой разработке и визуализации карта нормалей позволяет обмануть взгляд зрителя, создавая эффект высокодетализированной поверхности, не добавляя фактически новых полигонов. Вместо этого она использует специальные цветовые данные, которые кодируют информацию о направлении нормалей поверхности каждого пикселя.","Difficulty":60},{"Text":"Что такое Zenject?","Answers":["Это фреймворк для внедрения зависимостей.","Это алгоритм сжатия данных, используемый для уменьшения размера файлов в Unity.","Это инструмент для создания сложных математических вычислений и алгоритмов в Unity.","Это библиотека для работы с звуками и аудиоэффектами в Unity."],"CorrectAnswerIndex":0,"Explanation":"Zenject - это фреймворк для управления зависимостями и инъекции зависимостей (Dependency Injection, DI) в Unity. Он предоставляет удобные инструменты для организации структуры проекта и управления зависимостями между компонентами.","Difficulty":60},{"Text":"Какие из нижеперечисленных методов предназначены для создания или удаления объектов в Unity?","Answers":["Instantiate() и Destroy()","Start() и FixedUpdate()","Update() и LateUpdate()","OnEnable() и OnDisable()"],"CorrectAnswerIndex":0,"Explanation":"Instantiate(): Метод принимает параметром префаб (Prefab) - шаблон объекта, который нужно создать, и  дополнительные параметры, такие как позиция и поворот и создает новый экземпляр объекта.\n\nDestroy(): Этот метод используется для удаления игрового объекта со сцены во время игры. Он принимает в качестве параметра ссылку на удаляемый объект и уничтожает его, освобождая память и ресурсы, которые он занимал.","Difficulty":61},{"Text":"Где доступны члены с модификатором  internal?","Answers":["Внутри того же проекта (сборки).","Из любого места программы, включая другие классы и пространства имен.","Внутри того же класса и его производных классов (наследников).","Только внутри того же класса, в котором они объявлены."],"CorrectAnswerIndex":0,"Explanation":"internal - это уровень доступа, который ограничивает доступ к членам класса только внутри той сборки, в которой они объявлены. Сборка - это единица компиляции, которая может представлять собой одну библиотеку, исполняемый файл или модуль. Если член класса объявлен с модификатором internal, он может быть использован в любом другом классе, находящемся в той же сборке, но будет недоступен для классов вне этой сборки.","Difficulty":62},{"Text":"Кому нужна функция Collaborate в Unity Teams?","Answers":["Членам команды для сохранения, обмена и синхронизации проектов Unity.","Разработчикам, которые вносят изменения в исходный код Unity.","Компаниям, которые собирают деньги на проекты через краудфандинг.","Разработчики используют как систему контроля версий."],"CorrectAnswerIndex":0,"Explanation":"Функция Collaborate в Unity Teams нужна командам разработчиков, чтобы сохранять, совместно использовать и синхронизировать проекты Unity. Это обеспечивает более эффективную работу над проектами в команде, обмен файлами, контроль версий и совместное внесение изменений в проекты.","Difficulty":62},{"Text":"Зачем компонент PlayableDirector?","Answers":["Управлять воспроизведением временной шкалы в сцене.","Записать игровой сеанс в видеофайл.","Переключаться между различными камерами сцены.","Параллельно запускать несколько функций на разных игровых объектах."],"CorrectAnswerIndex":0,"Explanation":"Компонент PlayableDirector в Unity используется для управления временем и воспроизведения Timeline - это визуальной системы анимации, которая позволяет создавать сложные и интерактивные анимации событий в игре или приложении.\n\nPlayableDirector позволяет проигрывать, останавливать, приостанавливать и переключать Timeline во время выполнения приложения. Это удобно для создания сценариев и кинематографичных моментов, так как вы можете контролировать события и анимацию объектов на сцене через таймлайн и скрипты.","Difficulty":63},{"Text":"Что такое куча и стек?","Answers":["Стек - это область памяти, используемая для хранения локальных переменных, а куча - это область динамической памяти для хранения объектов.","Стек - это место, где хранятся объекты и данные, а куча - это область памяти, используемая для выполнения арифметических операций.","Стек - это область памяти, где хранятся данные времени выполнения программы, а куча - место, где хранятся инструкции и код программы.","Стек - это область памяти, где хранятся структуры данных, а куча - это место, где хранятся функции и методы программы."],"CorrectAnswerIndex":0,"Explanation":"Куча (heap) и стек (stack) - это две основные области памяти, используемые в программировании, включая C#.\n\nСтек (stack) - это область памяти, где хранятся локальные переменные методов, параметры методов, а также контекст вызова функций. Стек управляется автоматически и используется для хранения данных в порядке \"последний вошел - первый вышел\".\nКуча (heap) - это область динамической памяти, где хранятся объекты и данные, которые создаются и управляются во время выполнения программы. В отличие от стека, размер кучи не фиксирован и может изменяться во время выполнения. ","Difficulty":64},{"Text":"В чем состоит \"Принцип подстановки Барбары Лисков\" (3 принцип SOLID)?","Answers":["Объекты базовых классов должны быть заменяемыми объектами производных классов.","Производный класс должен быть наследником только одного базового класса.","Все методы базового класса были переопределены в производных классах.","Классы не могут быть изменены после их создания, чтобы обеспечить их стабильность."],"CorrectAnswerIndex":0,"Explanation":"Принцип подстановки Барбары Лисков:\n\"Объекты базовых классов должны быть заменяемыми объектами своих производных классов, и это не должно влиять на правильность программы.\"\n\nПредположим, у нас есть класс Bird с методом Fly(), и от него производные классы Penguin и Sparrow. По принципу LSP, мы должны быть уверены, что вызов метода Fly() на объектах Bird не вызовет ошибок или неожиданных поведений для классов Penguin и Sparrow. Может быть разумно переопределить метод Fly() для Penguin, чтобы он не делал ничего (так как пингвины не летают), но это не должно нарушать работу других частей программы, которые ожидают объекты типа Bird.","Difficulty":64},{"Text":"Что такое статический полиморфизм?","Answers":["Механизм, при котором одно и то же имя метода может использоваться для выполнения различных действий(перегрузка).","Механизм, позволяющий создавать новые методы во время выполнения программы.","Используется для выполнения разных действий в зависимости от значения переменной.","Механизм, обеспечивающий динамическое связывание вызовов методов."],"CorrectAnswerIndex":0,"Explanation":"Статический полиморфизм (также известный как перегрузка или компиляционный полиморфизм) - это механизм в программировании, при котором одно и то же имя метода или оператора может использоваться для выполнения различных действий в зависимости от типов аргументов, переданных в метод.\n\nСтатический полиморфизм разрешается во время компиляции программы, и компилятор определяет, какой именно метод или оператор должен быть вызван на основе типов аргументов, используемых в вызове функции. Это позволяет перегружать методы или операторы с различными типами параметров и обрабатывать их соответствующим образом.","Difficulty":65},{"Text":"Что такое batching в Unity?","Answers":["Это механизм, который позволяет объединить несколько объектов или графических элементов в один draw call.","Это процесс взаимодействия объектов с разными материалами для создания новых эффектов в игре.","Это техника, которая используется для управления пакетами данных в Unity.","Это метод оптимизации текстур и уровней детализации для улучшения графики в Unity."],"CorrectAnswerIndex":0,"Explanation":"Batching (объединение) в Unity - это процесс, при котором несколько графических элементов объединяются в один, чтобы уменьшить количество draw call и улучшить производительность игры.\nBatching помогает оптимизировать производительность игры, особенно при работе с большим количеством объектов на сцене. Однако не все объекты могут быть объединены, и оптимизация требует соблюдения определенных ограничений и правил.","Difficulty":66},{"Text":"Какое утверждение лучше всего описывает функцию Quaternion.Euler?","Answers":["Преобразует ориентацию, измеренную в градусах, в кватернион.","Преобразует кватернион в строку, которая хранит его вращение по осям X, Y и Z в градусах.","Преобразует ориентацию из радиан в кватернион.","Он преобразует кватернион в Vector3."],"CorrectAnswerIndex":0,"Explanation":"Метод Quaternion.Euler(x, y, z) в Unity используется для создания кватерниона, представляющего поворот вокруг осей X, Y и Z.\n\nОн принимает три значения в градусах: x, y и z, и возвращает кватернион, который представляет соответствующий поворот. Этот метод удобен для создания кватернионов, когда углы поворота заданы в удобном для разработчика формате в градусах.","Difficulty":66},{"Text":"Что подразумевается под \"управлением зависимостями\"?","Answers":["Это процесс установления, передачи и управления зависимостями между компонентами программы. ","Это способность обращаться к родительским компонентам и использовать их ресурсы.","Это процесс оценки взаимодействия между различными элементами программы и определения их важности.","Это способность программы автоматически создавать зависимости между компонентами без вмешательства программиста."],"CorrectAnswerIndex":0,"Explanation":"Зависимости - это отношения между различными компонентами, модулями или объектами программы, где один элемент (называемый клиентом или потребителем) требует доступа к другому элементу (называемому сервисом или поставщиком) для выполнения своих задач.\nУправление зависимостями - это процесс установления, передачи и управления зависимостями между компонентами программы. Один из способов управления зависимостями - это использование паттернов инъекции зависимостей (Dependency Injection, DI), которые позволяют создавать слабые связи между компонентами и обеспечивают более гибкую структуру программы.","Difficulty":67},{"Text":"Как получить ближайшую сверху к числу number степень двойки в С#?","Answers":["double result = Math.Pow(2, Math.Ceiling(Math.Log(number, 2)));","double result = Math.Log(number, 2);","double result = Math.Ceiling(Math.Pow(2, Math.Log(number, 2)));","double result = Math.Log(Math.Pow(Math.Ceiling(number)));"],"CorrectAnswerIndex":0,"Explanation":"Math.Pow(base, exponent) - функция, возводящая базу в указанный показатель степени.\nMath.Ceiling(value) - функция, округляющая значение вверх до ближайшего целого числа.\nMath.Log(number, base) - функция, вычисляющая натуральный логарифм числа по указанному основанию. \nТо есть, сначала вычистяем логарифм числа по основанию 2, округляем вверх и возводим 2 в  полученную степень. Полезно при вычислении буферов памяти и при работе с размерами текстур.","Difficulty":68},{"Text":"Что такое асимптотическая сложность алгоритма?","Answers":["Асимптотическая сложность - это оценка поведения алгоритма по мере увеличения размера входных данных.","Асимптотическая сложность - это количество операций, выполняемых в алгоритме, независимо от размера входных данных.","Асимптотическая сложность - это точное количество шагов, необходимых для выполнения алгоритма.","Асимптотическая сложность алгоритма - это количество байтов памяти, занимаемых алгоритмом в процессе выполнения."],"CorrectAnswerIndex":0,"Explanation":"Асимптотическая сложность позволяет оценить, как быстро растет время выполнения или количество ресурсов, таких как память или процессорное время, потребляемых алгоритмом при увеличении размера входных данных.\n\nАсимптотическая сложность обычно выражается с помощью \"О-большого\" (Big O) нотации. В нотации \"О-большого\" указывается верхняя граница роста алгоритма в зависимости от размера входных данных. Например, если сложность алгоритма оценивается как O(n^2), где n - размер входных данных, это означает, что время выполнения алгоритма будет расти пропорционально квадрату размера входных данных.","Difficulty":68},{"Text":"В чем состоит \"Принцип разделения интерфейса\" (4 принцип SOLID)?","Answers":["Много маленьких специализированных интерфейсов лучше, чем один общий интерфейс.","Интерфейс должен содержать как можно больше методов для упрощения кода.","Каждый интерфейс должны быть реализован одним классом, чтобы избежать дублирования кода.","Все классы должны реализовывать общий интерфейс с обязательными методами."],"CorrectAnswerIndex":0,"Explanation":"Принцип разделения интерфейса:\n\"Много маленьких специализированных интерфейсов лучше, чем один общий интерфейс.\"\nСуть этого принципа состоит в том, чтобы разделять большие и сложные интерфейсы на много маленьких и специализированных таким образом, чтобы клиенты могли реализовывать только те методы, которые им действительно необходимы, а не быть принужденными реализовывать лишние методы.","Difficulty":69},{"Text":"Чем абстрактный класс отличается от интерфейса?","Answers":["Абстрактный класс может предоставлять реализацию методов и свойств, в то время как интерфейс только определяет сигнатуры.","Абстрактный класс может использоваться для создания экземпляров объектов, в то время как интерфейс не может.","Абстрактный класс может реализовывать несколько интерфейсов, а интерфейс может наследовать только один абстрактный класс.","Абстрактный класс и интерфейс предоставляют одинаковую функциональность и могут использоваться взаимозаменяемо."],"CorrectAnswerIndex":0,"Explanation":"Абстрактный класс может предоставлять реализацию методов и свойств, в то время как интерфейс только определяет сигнатуры методов и свойств, но не предоставляет их реализацию. \nКласс может наследовать только один абстрактный класс, но реализовывать множество интерфейсов. \nАбстрактный класс может предоставлять общую функциональность для классов-наследников и определять базовую структуру и поведение. Интерфейсы определяют только контракты, которые класс должен реализовать, но не предоставляют общей реализации.\nАбстрактный класс может быть расширен путем добавления новых методов, свойств и полей, в то время как интерфейс, как правило, не подвержен изменениям, чтобы не нарушать существующие контракты.","Difficulty":70},{"Text":"От чего наследуется MonoBehaviour? ","Answers":["от класса Behaviour","от класса Class","от класса Object","от класса Component"],"CorrectAnswerIndex":0,"Explanation":"MonoBehaviour наследуется от класса Behaviour. Класс Behaviour в свою очередь наследуется от класса Component. Component является базовым классом для всех компонентов в Unity.","Difficulty":70},{"Text":"Что такое перегрузка операторов?","Answers":["Это возможность определить новое поведение операторов для пользовательских типов данных.","Это возможность менять порядок выполнения операций прямо во время выполнения программы.","Это возможность создавать новые операторы, не связанные с уже существующими.","Это конструкция с  ключевым словом overload, позволяющая выполнять оператор несколько раз подряд."],"CorrectAnswerIndex":0,"Explanation":"Перегрузка операторов - это механизм, который позволяет определить специальное поведение операторов при работе с объектами пользовательских классов. Это позволяет использовать стандартные операторы, такие как +, -, *, /, ==, !=, и другие, для объектов пользовательских классов, а также определить свою логику для их работы.\n    // Перегрузка оператора сложения\n    public static Point operator +(Point p1, Point p2)\n    {\n        return new Point(p1.X + p2.X, p1.Y + p2.Y);\n    }","Difficulty":71},{"Text":"Что такое переполнение стека (stack overflow)?","Answers":["Это ситуация, когда стек памяти заполняется больше, чем его максимальная емкость.","Это ошибка, при попытке присвоить значение переменной, которое выходит за пределы диапазона этой переменной.","Это ситуация, когда программе не хватает оперативной памяти для выполнения задач.","Это ошибка, возникающая при попытке доступа к несуществующей памяти или объекту в программе."],"CorrectAnswerIndex":0,"Explanation":"Переполнение стека (stack overflow) - это ситуация, когда стек памяти, используемый для хранения локальных переменных, параметров методов и контекста вызова функций, заполняется больше, чем его максимальная емкость. \n\nПереполнение стека обычно происходит, когда рекурсивная функция вызывает саму себя или когда вложенные функции вызываются слишком глубоко и не освобождаются из стека вовремя. \n\nПри переполнении стека обычно возникает исключение \"StackOverflowException\", которое приводит к прекращению работы программы или аварийному завершению. ","Difficulty":72},{"Text":"Что такое Animation Rigging в Unity?","Answers":["Это система для создания и управления сложными анимациями с помощью управляемых костей и контролов.\n\n\n\n\n\n","Это метод для управления положением объектов в сцене с помощью уравнений кинематики.","Это технология для создания и управления светом в сцене.","Это система для оптимизации и управления ресурсами в проекте."],"CorrectAnswerIndex":0,"Explanation":"Animation Rigging в Unity - это набор инструментов и система, которая позволяет создавать сложные анимации персонажей и объектов с использованием программных контроллеров и управлять костями и мешами для достижения более реалистичных и уникальных движений. Это позволяет аниматорам и разработчикам создавать более динамичные и интересные анимации, а также упрощает процесс анимирования сложных объектов и персонажей.","Difficulty":72},{"Text":"Можно ли хранить разные типы данных в C# в объекте класса System.Array?","Answers":["Хранение разных типов данных в массиве возможно, но в виде объектов.","Хранение разных типов данных в массиве приводит к потере точности и ошибкам при доступе к элементам.","System.Array автоматически преобразует все элементы в единый тип данных.","Нет, в массиве можно хранить только однородные элементы одного типа данных."],"CorrectAnswerIndex":0,"Explanation":"System.Array является базовым классом для всех массивов в C# и позволяет хранить элементы различных типов в единственном массиве.\nArray myArray = new object[5];\nmyArray[0] = \"Привет\";\nmyArray[1] = 10;\nmyArray[2] = true;\nmyArray[3] = 3.14;\nmyArray[4] = DateTime.Now;\nОднако, при работе с System.Array следует учитывать, что элементы хранятся в виде объектов, и при доступе к ним может потребоваться явное приведение типа обратно к исходному типу для использования конкретных функций или свойств. ","Difficulty":73},{"Text":"В чем состоит \"Принцип инверсии зависимостей\" (5 принцип SOLID)?","Answers":["Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций.","Высокоуровневые модули должны зависеть от низкоуровневых модулей, абстракции должны зависеть от деталей.","Классы должны зависеть только от конкретных реализаций, а не от абстракций.","Классы должны быть написаны так, чтобы они не могли изменить свое поведение во время выполнения."],"CorrectAnswerIndex":0,"Explanation":"Принцип инверсии зависимостей:\nВысокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций.\nАбстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\nПредположим, у нас есть класс OrderProcessor, который зависит от класса DatabaseConnection для доступа к базе данных. Если мы хотим использовать другой источник данных, нам придется изменить класс OrderProcessor. Вместо этого, мы можем ввести абстракцию, например, интерфейс IDatabaseConnection, и сделать OrderProcessor зависимым только от этого интерфейса. Теперь мы можем легко заменить DatabaseConnection другой реализацией, не затрагивая OrderProcessor.","Difficulty":74},{"Text":"Для чего обычно используется событие OnAnimatorMove в объектах MonoBehaviour?","Answers":["Для перехвата и обработки обновлений позиции и вращения анимированного объекта.","Для воспроизведения анимации после ее завершения.","Для синхронизации анимации объекта с текущим временем.","Для обнаружения любого движения объекта."],"CorrectAnswerIndex":0,"Explanation":"Событие OnAnimatorMove в объектах MonoBehaviour обычно используется для перехвата и обработки обновлений позиции и вращения объекта, которые были применены аниматором в кадре. Это позволяет программисту влиять на движение объекта, учитывая анимацию, и добавлять дополнительную логику, связанную с движением и анимацией, в скрипты объекта.","Difficulty":74},{"Text":"Какой фрагмент кода C# постоянно обновляет ось Y?","Answers":["transform.Rotate(Vector3.right, RotSpeed * Time.deltaTime);","transform.localRotation *= Quaternion.Euler(0f, RotSpeed * Time.deltaTime, 0f);","transform.RotateAround(Vector3.up, RotSpeed * Time.deltaTime);","transform.SetParent(null);"],"CorrectAnswerIndex":0,"Explanation":"Метод transform.Rotate в Unity используется для вращения игрового объекта в трехмерном пространстве. Он позволяет изменить ориентацию объекта относительно его текущего положения.","Difficulty":75},{"Text":"Как yield используется в итераторах?","Answers":["yield используется для определения значений, которые должны быть возвращены при каждой итерации.","yield используется для объявления переменных в итераторах.","yield используется для создания делегатов и событий в C#.","yield используется для определения начала выполнения каждой итерации."],"CorrectAnswerIndex":0,"Explanation":"В итераторах yield используется для определения значений, которые должны быть возвращены при каждой итерации. Когда исполнение доходит до инструкции yield return, значение возвращается из итератора, а выполнение приостанавливается. \npublic static IEnumerable<int> GetNumbers()\n    {\n        yield return 1;\n        yield return 2;\n        yield return 3;\n        yield return 4;\n        yield return 5;\n    }","Difficulty":76},{"Text":"Что такое Assets Bundle?","Answers":["Пакет, содержащий один или несколько файлов ресурсов.","Специальная папка, содержащая скрипты и ресурсы.","Устаревший и не используемый в Unity способ управления ресурсами, замененный другими методами.","Формат файлов для хранения компилированных скриптов в Unity."],"CorrectAnswerIndex":0,"Explanation":"Assets Bundle (пакет ресурсов) в Unity - это специальный файл, который содержит один или несколько ресурсов (таких как текстуры, модели, аудио, видео и другие) упакованных в одну единицу. Эти пакеты могут быть созданы и загружены в игре динамически, что позволяет управлять ресурсами более эффективно.\nAssets Bundle предоставляют разработчикам более гибкий и эффективный способ управления ресурсами в Unity, что особенно важно для мобильных платформ и игр с большим объемом контента.","Difficulty":76},{"Text":"Что такое Shader Graph в Unity?","Answers":["Это визуальный графический инструмент, который позволяет создавать шейдеры без необходимости писать код. ","Это плагин для Unity, который позволяет экспортировать графические эффекты.","Это компонент в Unity, который позволяет создавать динамические визуальные эффекты для объектов на сцене.","Это система в Unity, которая отвечает за управление физической симуляцией объектов."],"CorrectAnswerIndex":0,"Explanation":"Shader Graph в Unity - это визуальный графический инструмент, который позволяет создавать шейдеры (материалы) для объектов на сцене без необходимости писать код. Он предоставляет интерфейс для создания комплексных шейдеров с помощью соединения готовых блоков, представляющих различные шейдерные функции и операции.","Difficulty":77},{"Text":"Игровой объект пули быстро перемещается по сцене с помощью компонента RigidBody. Иногда он проходит сквозь твердые объекты, даже когда у них есть коллайдер. Как это исправить?","Answers":["Изменить свойство Collision Detection Rigidbody на Continuous Dynamic или Continuous Speculative.","Включить свойство Rigidbody IsKinematic.","Увеличить значение Fixed Time Step в диалоговом окне Project Settings, чтобы изменить частоту события FixedUpdate.","Надо увеличить размер коллайдеров, чтобы более эффективно обнаруживать столкновения."],"CorrectAnswerIndex":0,"Explanation":"У Collision Detection, отвечающий за обнаружение столкновений есть несколько параметров:\nDiscrete: Значение по умолчанию. Столкновения обрабатываются на основе расчетов за каждый кадр. Это подходит для большинства объектов.\nContinuous: Используется непрерывная обработка столкновений. Это позволяет предотвратить проникновение объектов друг в друга при высоких скоростях. Однако этот режим затратен с точки зрения производительности.\nContinuous Dynamic: Этот режим комбинирует преимущества дискретной и непрерывной обработки столкновений.\nContinuous Speculative: Это расширение режима Continuous, которое делает предположения о будущем положении объекта на основе его скорости.","Difficulty":78},{"Text":"Что такое Lerp в Unity ?","Answers":["Lerp - это метод, который позволяет плавно перемещаться между двумя значениями.","Lerp - это аббревиатура от \"Lighting Effects Render Pipeline\", специальной технологии для улучшения рендера света.","Lerp - это тип материала, применяемый к объектам для изменения их физических свойств, таких как упругость или трение.","Lerp - это специальный вид игровых персонажей, которые перемещаются по заданной траектории на экране."],"CorrectAnswerIndex":0,"Explanation":"В Unity Lerp (Linear Interpolation) является функцией, предоставляемой внутри фреймворка Unity для выполнения линейной интерполяции между двумя значениями в рамках временной оси. Функция Lerp в Unity может использоваться для плавного перемещения объектов, изменения их размера, изменения цвета или прозрачности, а также для создания анимации между двумя значениями.\n\nВ Unity функция Lerp использует следующий синтаксис:\nVector3.Lerp(start, end, t);\nstart и end - начальное и конечное значения, между которыми выполняется интерполяция.\nt - весовой коэффициент (время), находящийся в диапазоне от 0 до 1. ","Difficulty":78},{"Text":"Что такое Nullable-тип в C#?","Answers":["Специальный тип данных, который позволяет переменной принимать значение null.","Позволяет переменной иметь только значение \"null\" и никакое другое.","Представляет специальный тип данных, который может изменять свой тип во время выполнения программы.","Позволяет переменной иметь несколько значений одновременно."],"CorrectAnswerIndex":0,"Explanation":"Nullable-тип в C# представляет возможность для переменной иметь дополнительное значение \"null\" в дополнение к её основному типу данных. Обычные типы данных в C#, такие как int, bool, double и другие, не могут содержать значение \"null\". Однако, если мы хотим, чтобы переменная могла принимать значение \"null\", мы можем использовать Nullable-тип. Nullable-тип создается путем добавления символа \"?\" после основного типа данных. Например, int? означает Nullable-тип для целочисленного значения.\nint? nullableInt = null;\nbool? nullableBool = true;\ndouble? nullableDouble = 3.14;","Difficulty":79},{"Text":"Что такое динамический полиморфизм?","Answers":["Это механизм, позволяющий использовать разным объектам методы с одинаковым именем (переопределение методов).","Механизм, при котором одно и то же имя метода может использоваться для выполнения различных действий(перегрузка).","Это механизм, позволяющий использовать разные объекты без указания их конретного типа.","Это механизм, позволяющий динамичестки  определять, нужен ли полиморфизм или нет."],"CorrectAnswerIndex":0,"Explanation":"Динамический полиморфизм - это механизм, который позволяет объектам различных классов реагировать на вызовы методов с одинаковыми именами, но с разной реализацией, во время выполнения программы.\n\nДинамический полиморфизм достигается через наследование и виртуальные методы. Когда метод объявлен с ключевым словом virtual в базовом классе и переопределен (override) в производном классе с использованием ключевого слова override, во время выполнения вызывается метод из производного класса, а не базового класса, в соответствии с типом объекта, на котором вызывается метод.","Difficulty":80},{"Text":"Что такое Scriptable Objects в Unity3D и для чего они используются?","Answers":["Это тип объектов, который позволяет создавать и хранить данные.","Это компоненты для работы с физическими эффектами.","Это система для создания анимаций персонажей.","Это компоненты для работы с UI элементами."],"CorrectAnswerIndex":0,"Explanation":"Scriptable Objects в Unity3D - это особый тип объектов, который позволяет создавать и хранить данные, которые можно использовать в проекте. Они представляют собой классы, которые могут содержать переменные и методы, но не требуют наличия GameObject в сцене.\nПрименение:\nХранение и настройка данных о персонажах, оружии, предметах, уровнях и других игровых объектах.\nУправление состоянием и поведением AI.\nСоздание систем для генерации уровней или случайных событий.\nСохранение настроек пользовательского интерфейса и управления анимациями.","Difficulty":80},{"Text":"Как можно оптимизировать работу UI элементов в Unity?","Answers":["Сгруппировать статические UI на одном канвасе, а динамические элементы — на другом.","Расположить все объекты на канвасе в начале координат.","Сгруппировать абсолютно все UI элементы на одном канвасе.","Разделить экран на 4 части, в каждой создать отдельный канвас."],"CorrectAnswerIndex":0,"Explanation":"Разделение на статические и динамические элементы позволяет использовать различные подходы к оптимизации для каждого типа. Статические элементы обрабатываются на этапе разработки, что снижает нагрузку на процессор во время игры. В то же время, динамические элементы обновляются в реальном времени, что обеспечивает гибкость и интерактивность в игре.","Difficulty":81},{"Text":"Что такое Unity DOTS ?","Answers":["Это стек технологий, для разработки высокоэффективных игр с использованием принципов ориентированных на данные.","это расширение для создания трехмерных точек в игре, которые могут быть использованы для создания эффектов и специальных визуальных элементов.","Это плагин для управления объектами в сцене и их анимациями.","Это система управления версиями и совместной разработки игр на платформе Unity."],"CorrectAnswerIndex":0,"Explanation":"Unity DOTS (Data-Oriented Technology Stack) - это набор технологий и подходов, предоставляемых Unity для оптимизации производительности и управления данными в играх. Основной идеей DOTS является ориентированность на данные, что позволяет эффективно использовать многопоточность.\n\nDOTS включает в себя:\n\nECS (Entity Component System), Burst Compiler, Jobs System.\n\nDOTS позволяет разработчикам создавать более производительные и масштабируемые игры, особенно на платформах с многопоточными процессорами. ","Difficulty":82},{"Text":"Чем корутины отличаются от асинхронных методов?","Answers":["Корутина выполняется в основном потоке. Асинхронные методы могут выполняться как в основном, так и в фоновых потоках.","Корутины используют ключевое слово await, а асинхронные методы используют ключевое слово yield.","Корутины более эффективны и быстрые по сравнению с асинхронными методами.","Корутина выполняется в фоновых потоках. Асинхронные методы выполняются в основном потоке."],"CorrectAnswerIndex":0,"Explanation":"Корутины в Unity выполняются в основном потоке. Они используют механизм yield для приостановки и возобновления выполнения, что позволяет создавать асинхронные задачи без блокировки основного потока и, таким образом, не приводят к замедлению обновления кадров в игре.\n\nАсинхронные методы в Unity, которые используют ключевое слово async, могут выполняться как в основном потоке, так и в фоновых потоках, в зависимости от того, какой именно код выполняется асинхронно. ","Difficulty":82},{"Text":"Какой инструмент Unity позволяет создавать и редактировать анимации в формате timeline?","Answers":["Timeline Window","Animation Window","Animator Controller","Inspector"],"CorrectAnswerIndex":0,"Explanation":"Timeline Window (Окно временных шкал) в Unity представляет собой инструмент для создания и редактирования сложных временных линий, которые позволяют управлять анимациями, событиями, звуками и другими элементами в игре. Оно позволяет создавать кинематографические сцены и событийные последовательности, а также управлять временными параметрами объектов в игровом мире. Timeline Window часто используется для создания кинематических сценариев, вступительных роликов, анимаций камеры и комплексных анимационных последовательностей.","Difficulty":83},{"Text":"Разработчик выполняет следующий C#-код, который ищет все игровые объекты с тегом \"Enemy\". Однако при выполнении FindGameObjectsWithTag возвращает NULL, несмотря на то, что в сцене есть объекты с тегом \"Enemy\". Какая возможная причина?\nGameObject[] MyEnemies = GameObject.FindGameObjectsWithTag(\"Enemy\");","Answers":["Объекты не активны","Объекты должны содержать \"Enemy\" в имени","Объекты находятся на слое UI","Объекты анимированы"],"CorrectAnswerIndex":0,"Explanation":"Метод FindGameObjectsWithTag в Unity не находит неактивные объекты по умолчанию из-за оптимизации производительности. По умолчанию, поиск происходит только среди активных объектов на сцене, чтобы уменьшить нагрузку на процессор и память.\n\nЕсли разработчик хочет найти неактивные объекты с тегом, можно использовать дополнительную логику. Например, можно создать список активных и неактивных объектов с данным тегом и потом объединить их в один список для дальнейшей обработки. ","Difficulty":84},{"Text":"Каким образом отрицательные числа представляются в памяти компьютера?","Answers":["Отрицательные числа представляются путем инвертирования всех битов положительного числа и добавления единицы к результату.","При представлении отрицательных чисел используется дополнительный бит, указывающий, что число отрицательное.","Отрицательные числа представляются с использованием десятичной системы счисления, но с отрицательным знаком, например \"-5\".","Отрицательные числа представляются в памяти компьютера с использованием фракций, которые отражают их отрицательное значение."],"CorrectAnswerIndex":0,"Explanation":"Для получения двоичного отрицательного числа, необходимо выполнить следующие шаги:\nПредставьте число положительным числом в двоичной форме.\nИнвертируйте все биты числа (замените 0 на 1 и 1 на 0).\nДобавьте единицу к результату предыдущего шага.\n\nНапример, для представления -5 в 8-битном двоичном виде:\nПредставление положительного числа 5: 00000101.\nИнверсия всех битов: 11111010.\nДобавление единицы: 11111011.\nТаким образом, -5 представляется в памяти компьютера как 8-битное число 11111011.","Difficulty":84},{"Text":"Что такое замыкание (closure) в C#? ","Answers":["Замыкание - это функция, которая запоминает и использует значения переменных из внешней области видимости.","Замыкание  - это процесс закрытия и защиты доступа к переменным, чтобы они не могли быть изменены из других частей кода.","Замыкание - это специальный синтаксис, который используется для создания анонимных методов.","Замыкание - это функция, которая автоматически вызывается при инициализации переменной."],"CorrectAnswerIndex":0,"Explanation":"Замыкание (closure) в C# - это функция, которая захватывает и удерживает в памяти значения переменных из внешней области видимости, в которой она была создана, даже после того, как эта область видимости завершила свое выполнение.\n\npublic static Func<int, int> CreateMultiplier(int factor)\n{\n    return x => x * factor;\n}\nvar multiplierBy2 = CreateMultiplier(2);\nvar result = multiplierBy2(5);\n\nФункция CreateMultiplier создает и возвращает лямбда-выражение, которое умножает переданное число на фактор. При каждом вызове CreateMultiplier создается новое замыкание, которое запоминает значение фактора и использует его при вызове полученной функции multiplierBy2. ","Difficulty":85},{"Text":"В чём разница между ключевыми словами finally и finalize?","Answers":["finally используется в блоке try-catch, finalize вызывается при удалении объекта.","finally и finalize это одно и то же, но один используют с классами, а другой с методами и полями.","finally вызывается сборщиком мусора, finalize - блок, который игнорирует появление ошибки и вызывается в любом случае.","finally используется для определения окончания блока кода, finalize принудительно завершает выполнение программы."],"CorrectAnswerIndex":0,"Explanation":"finally является блоком кода в C#, который используется в связке с блоками try и catch для выполнения кода, который должен быть выполнен независимо от того, произошло исключение или нет.\nfinalize является методом в C#, который вызывается сборщиком мусора перед окончательным удалением объекта из памяти.","Difficulty":86},{"Text":"Что такое Normal Mapping в Unity?","Answers":["Процесс изменения нормалей поверхности для создания иллюзии дополнительной детализации.","Метод оптимизации работы с физическими материалами в сцене.","Механизм для определения столкновений объектов в игровой сцене.","Метод для оптимизации использования ресурсов видеокарты при рендеринге сцены."],"CorrectAnswerIndex":0,"Explanation":"Normal Mapping в Unity - это техника, используемая для добавления дополнительной детализации и реалистичности к поверхностям объектов без изменения их геометрии. Это позволяет создавать визуально более сложные и текстурные объекты, не увеличивая количество полигонов, что положительно сказывается на производительности.\n\nТехника Normal Mapping основана на использовании текстур, называемых Normal Maps, которые содержат информацию о нормалях (направлениях поверхности) для каждого пикселя объекта. Эти нормали используются для определения, как свет взаимодействует с поверхностью, создавая иллюзию выступов и впадин.","Difficulty":86},{"Text":"Cinemachine предлагает инструменты для построения игрового поведения. Какой компонент создает траектории на основе сплайнов для движущихся объектов?","Answers":["Cinemachine Smooth Path","Cinemachine Target Group"," Cinemachine Free Look","Cinemachine Brain"],"CorrectAnswerIndex":0,"Explanation":"Компонент Cinemachine Smooth Path используется для создания плавных путей (траекторий) для перемещения объектов в Unity. Это позволяет легко задавать сложные траектории движения для камеры или других игровых объектов с помощью сплайнов, что улучшает анимацию и визуальный опыт в игре.","Difficulty":87},{"Text":"Что такое Reflection в C#?","Answers":["Reflection - это механизм, который позволяет анализировать и модифицировать свою структуру и поведение во время выполнения. ","Reflection - это технология, которая позволяет программе отслеживать и регистрировать изменения в базе данных.","Reflection  - это механизм, который автоматически рефакторит код, чтобы улучшить его производительность и читаемость.","Reflection - это процесс создания отражений на поверхности объектов в трехмерном пространстве с учетом нормалей."],"CorrectAnswerIndex":0,"Explanation":"Reflection (отражение) в C# - это механизм, который позволяет программе анализировать, извлекать информацию о типах, а также взаимодействовать с ними во время выполнения программы. С помощью Reflection можно получить доступ к метаданным типов, таким как поля, свойства, методы, конструкторы, атрибуты и другие детали типа.\n\nReflection позволяет динамически создавать экземпляры типов, вызывать их методы, устанавливать и получать значения свойств, анализировать и изменять структуру типов на основе метаданных во время выполнения программы.","Difficulty":88},{"Text":"Почему Dictionary работает быстрее, чем List?","Answers":["Dictionary быстрее, благодаря использованию хэш-таблиц для хранения данных.","Dictionary быстрее, потому что он использует \"магический\" алгоритм поиска, который выполняется мгновенно.","Dictionary быстрее, благодаря современным и эффективным алгоритмам сравнения элементов.","Dictionary быстрее, потому что его элементы автоматически сортируются по ключам, что упрощает поиск."],"CorrectAnswerIndex":0,"Explanation":"В Dictionary каждый элемент хранится в виде пары ключ-значение. Он использует хэш-таблицу для эффективного доступа к элементам по ключу. Хэш-таблица позволяет выполнять операции добавления, удаления и поиска элементов за константное время (O(1)), в среднем. \n\nДоступ к элементам в List осуществляется по индексу. При поиске элемента в List требуется выполнить линейный поиск, просматривая каждый элемент до нахождения нужного индекса. Это занимает время пропорциональное размеру списка, то есть O(n), где n - количество элементов в списке.","Difficulty":88},{"Text":"Что такое \"графический проход\" (Graphics Pass) в рамках Scriptable Render Pipeline (SRP) в Unity?","Answers":["Шаг в процессе отрисовки объектов на экране.","Метод для передачи данных между CPU и GPU.","Механизм для объединения различных ассетов в один бандл.","Технология для управления памятью и оптимизации ресурсов."],"CorrectAnswerIndex":0,"Explanation":"Графический проход (Graphics Pass) в рамках Scriptable Render Pipeline (SRP) в Unity представляет собой один из этапов процесса отрисовки объектов на экране. SRP позволяет разработчикам более гибко контролировать процесс рендеринга, разбивая его на отдельные проходы, каждый из которых выполняет определенные операции с графическими данными.\nКаждый графический проход выполняет определенные шаги обработки данных, такие как: применение шейдеров, настройка материалов, расчет освещения, запись результатов в буферы кадра и т.д. Каждый проход определяет свой порядок операций и может использоваться для рендеринга определенных типов объектов или применения определенных эффектов.","Difficulty":89},{"Text":"Какой атрибут C# позволяет запускать класс и его методы внутри редактора в режиме редактирования?","Answers":["[ExecuteAlways]","[Range(0,10)]","[Live]","[Editor]"],"CorrectAnswerIndex":0,"Explanation":"Атрибут [ExecuteAlways] применяется к методам в классах MonoBehaviour в Unity. Он указывает, что метод должен выполняться как в режиме редактора (Editor mode), так и в режиме игры (Play mode). Этот атрибут полезен, когда вы хотите, чтобы определенный метод работал как в редакторе, так и во время игры, что может упростить разработку и тестирование игры.\n\nОсновное назначение атрибута [ExecuteAlways] заключается в том, чтобы предоставить доступ к редакторским функциям и методам в процессе разработки игры, чтобы увидеть результаты изменений в сцене в редакторе и игре. ","Difficulty":90},{"Text":"Что такое Scriptable Render Pipeline (SRP) в Unity и для чего он используется?","Answers":["Это метод работы с рендерингом в Unity для создания кастомных рендеринговых решений.","Это инструмент для управления зависимостями в Unity проектах.","Это специальная система управления асинхронным кодом в Unity.","Это компонент Unity, позволяющий создавать сложные анимации."],"CorrectAnswerIndex":0,"Explanation":"Scriptable Render Pipeline (SRP) - это новый подход к рендерингу в Unity, который позволяет разработчикам создавать кастомные рендеринговые решения. Он предоставляет гибкость и контроль над процессом рендеринга, позволяя оптимизировать производительность и достичь высококачественных визуальных эффектов.\n\nПрименение SRP особенно актуально для больших проектов, которые требуют высокой степени оптимизации и масштабируемости. Он также позволяет упростить разработку для разных платформ, так как можно создать отдельные рендеринговые решения для мобильных устройств, десктопов и консолей.","Difficulty":90},{"Text":"В чем разница между Lambda и Expression в C#?","Answers":["Lambda - компактный синтаксис анонимных функций. Expression - объектная модель для представления логической структуры выражений.","Lambda - для создания функций с фиксированным набором параметров. Expression позволяет работать с переменным числом параметров.","Lambda используется для функционального программирования, а Expression - для объектно-ориентированного программирования.","Lambda и Expression - это два разных способа создания анонимных функций в C#."],"CorrectAnswerIndex":0,"Explanation":"Lambda - это сокращенная и компактная форма записи анонимных функций в C#. Они позволяют создавать функции \"на лету\" без явного определения имени функции. \nFunc<int, int, int> addNumbers = (x, y) => x + y;\nExpression - это часть системы типов Expression Tree в C#. Они позволяют представлять логику выражений в виде объектной модели, что делает их доступными для динамической модификации и выполнения во время выполнения программы. \n        ParameterExpression x = Expression.Parameter(typeof(int), \"x\");\n        ParameterExpression y = Expression.Parameter(typeof(int), \"y\");\n        BinaryExpression sum = Expression.Add(x, y);","Difficulty":91},{"Text":"Что такое Jobs System в Unity?","Answers":["Это система для управления задачами в фоновом режиме и оптимизации производительности.","Это система для создания и управления работой разработчиков в Unity.","Это компонент, позволяющий управлять процессом загрузки ресурсов в игре.","Это технология для создания и управления различными заданиями в редакторе Unity."],"CorrectAnswerIndex":0,"Explanation":"Jobs System в Unity представляет собой систему для выполнения параллельных вычислений на многопоточных процессорах. Он позволяет распределять вычислительные задачи между несколькими потоками, чтобы повысить производительность и улучшить производительность приложения.","Difficulty":92},{"Text":"Поле поиска в окне проекта может фильтровать отображение ассетов с помощью текстовых команд. Какая команда отобразит только текстуры?","Answers":["T:texture"," T:mesh"," T:mesh"," Show textures"],"CorrectAnswerIndex":0,"Explanation":"\nДля окна поиска в Unity есть несколько команд, которые позволяют фильтровать отображение ассетов:\n\n\"t:Type\" - отображает ассеты указанного типа. Например, \"t:Prefab\" отобразит только префабы.\n\"l:Label\" - отображает ассеты с указанной меткой . \n\"b:BuildSettings\" - отображает ассеты, связанные с настройками сборки.\n\"d:Script\" - отображает скрипты.\n\"n:Name\" - отображает ассеты, чьи имена содержат указанный текст.\n\"p:Package\" - отображает ассеты из указанного пакета.\n\"a:AnimationClip\" - отображает анимационные клипы.\n\"s:Shader\" - отображает шейдеры.","Difficulty":92},{"Text":"Что такое Shadow mapping в Unity?","Answers":["Техника для визуализации теней объектов в сцене.","Метод обхода коллизий для объектов в тени.","Алгоритм для оптимизации отрисовки объектов с использованием теней.","Метод для управления светом и его взаимодействия с объектами."],"CorrectAnswerIndex":0,"Explanation":"Shadow mapping (теневая картировка) в Unity - это техника генерации теней в 3D-сценах. Она используется для визуального эффекта проецирования теней от источника света на объекты сцены. Применяется для достижения реалистичности визуализации, так как тени играют важную роль в восприятии объемности и глубины окружающего мира.","Difficulty":93},{"Text":"Что такое Light Probe Proxy Volume (LPPV) в Unity?","Answers":["Это компонент Unity, используемый для управления освещением и рассеянным светом в динамических сценах.","Это специальный вид коллайдера, который позволяет объектам взаимодействовать с окружающими световыми зондами.","Это инструмент для создания фотореалистичных отражений на объектах.","Это функция Unity, позволяющая создавать и управлять анимацией световых источников."],"CorrectAnswerIndex":0,"Explanation":"Light Probe Proxy Volume (LPPV) в Unity - это компонент, который используется для улучшения качества освещения в сценах с динамическими объектами и перемещающимися персонажами.\n\nLPPV позволяет уменьшить количество световых зондов, используемых в сцене, при этом сохраняя высокое качество освещения. Он используется для оптимизации производительности и уменьшения нагрузки на графический процессор.\n\nLPPV позволяет создавать гладкие переходы между различными зонами освещения и повышает реалистичность отображаемых сцен. Этот компонент особенно полезен для больших и сложных сцен с разнообразными источниками света.","Difficulty":94},{"Text":"Что такое Post-Processing Stack в Unity?","Answers":["Это набор для пост-обработки, используемый для добавления различных эффектов камеры.","Это инструмент для создания пост-обработки аудиоэффектов в игре.","Это технология для создания и настройки физических эффектов, таких как взрывы и дым.","Это система для создания и управления искусственным освещением в игре."],"CorrectAnswerIndex":0,"Explanation":"Post-Processing Stack в Unity - это пакет инструментов, предназначенный для добавления и настройки пост-обработки графики в игре. Он позволяет применять различные эффекты после прохождения процесса рендеринга, такие как цветокоррекция, размытие, глубина резкости и другие, чтобы улучшить визуальное восприятие игры.","Difficulty":94},{"Text":"Что такое occlusion culling в Unity и как он улучшает производительность?","Answers":["Это метод оптимизации отрисовки объектов за сценой, которые не видны из текущей камеры.","Это метод оптимизации анимаций в Unity."," Это компонент Unity для работы с искусственным интеллектом.","Это инструмент для создания кастомных шейдеров в Unity."],"CorrectAnswerIndex":0,"Explanation":"Occlusion Culling (окклюзионная сортировка) в Unity - это техника оптимизации рендеринга, которая позволяет исключить из отрисовки объекты, которые находятся за другими объектами и не видны из текущей камеры. \n\nРезультатом применения occlusion culling является снижение количества отрисованных объектов, сокращение затрат по процессору и видеокарте, а также повышение частоты кадров и общей производительности проекта. Особенно это актуально для больших сцен с множеством сложных объектов, например, в 3D-играх или симуляторах.","Difficulty":95},{"Text":"Unity автоматически прикрепляет компонент SkinnedMeshRenderer к некоторым мешам, когда они добавляются в сцену. Почему это происходит?","Answers":["Файл меша содержит кости и скелетную анимацию.","Игровой объект имеет компонент аниматора.","Объект — персонаж, управляемый игроком.","Файл сетки содержит гуманоидного персонажа."],"CorrectAnswerIndex":0,"Explanation":"SkinnedMeshRenderer - это компонент в Unity, который используется для отображения и анимации 3D-моделей, которые имеют скелетную анимацию. Он используется для отображения скиннед (скелетно-анимированных) мешей.\n\nСкиннед меш - это 3D-модель, состоящая из вершин (vertices), которые связаны с костями (bones) с помощью весов (weights). Кости образуют сетку, и каждая вершина может быть привязана к одной или нескольким костям. Веса определяют, насколько каждая вершина будет двигаться вместе с соответствующей костью. Это позволяет создавать реалистичную и гибкую анимацию для персонажей, животных и других скиннед объектов.","Difficulty":96},{"Text":"Что такое IK (Inverse Kinematics) в Unity?","Answers":["Это техника для создания реалистичной анимации движения объектов в сцене.","Это компонент, позволяющий создавать и управлять системами частиц в игре.","Это альтернативный метод визуализации игровых объектов с использованием специальных материалов.","Это алгоритм для оптимизации работы с физическими материалами в игре."],"CorrectAnswerIndex":0,"Explanation":"Inverse Kinematics (обратная кинематика) в Unity - это методика моделирования движения объектов таким образом, чтобы заданное положение и ориентация определенной точки (или точек) объекта были достигнуты за счет изменения параметров суставов или сочленений модели. Основная идея обратной кинематики заключается в том, чтобы определить значения углов, необходимые для достижения желаемой позиции и ориентации, исходя из известного положения и ориентации конечных точек объекта.","Difficulty":96},{"Text":"Что такое Addressable Assets System в Unity?","Answers":["Это система для организации и управления ресурсами, которая позволяет загружать их динамически в проекте.","Это компонент Unity для работы с базой данных.","Это система для упаковки ресурсов в один файл для упрощения их распространения."," Это инструмент для работы с файловой системой и путями в Unity."],"CorrectAnswerIndex":0,"Explanation":"С помощью Addressable Assets System разработчики могут создавать адресуемые ресурсы, которые имеют уникальные идентификаторы (адреса). \nФишки AAS:\nДинамическая загрузка: Ресурсы можно загружать и выгружать по мере необходимости.\nГибкость: Адреса ресурсов можно менять и обновлять без изменения кода.\nАвтоматическое управление памятью: AAS автоматически управляет выгрузкой ресурсов, которые больше не используются.\nЛокализация: Ресурсы можно легко локализовать, заменяя адресуемые ассеты на соответствующие локализованные версии.\nУправление версиями: AAS предоставляет возможность управлять версиями ресурсов.","Difficulty":97},{"Text":"Что такое Burst Compiler?","Answers":["Это технология для генерации высокоэффективного нативного кода из методов C# для улучшения производительности.","Это средство для создания визуальных эффектов и шейдеров в Unity.","Это плагин, который позволяет разработчикам обмениваться своими проектами и ресурсами с другими командами в Unity.","Это инструмент для быстрого создания сложных анимаций и переходов между состояниями объектов в Unity."],"CorrectAnswerIndex":0,"Explanation":"Burst Compiler - это технология в Unity, которая предоставляет возможность генерировать высокоэффективный нативный код для определенных методов C# или C#.NET, особенно для использования с Unity Job System. Он позволяет оптимизировать вычисления и ускорить выполнение кода за счет использования специальных оптимизаций и возможности многопоточности.\n\nВажно отметить, что Burst Compiler не может использоваться для всех методов, а только для тех, которые удовлетворяют определенным ограничениям и условиям. Он обычно используется совместно с Unity Job System и Unity DOTS для достижения высокой производительности в игровых проектах.","Difficulty":98},{"Text":"Что такое \"deferred rendering\" (отложенная отрисовка) и  \"forward rendering\" (прямая отрисовка) в Unity?","Answers":["Алгоритмы для вычисления освещения и применения шейдеров","Различные настройки камеры для создания разных эффектов","Методы оптимизации для уменьшения числа отрисовок объектов","Механизмы для обработки коллизий и столкновений объектов"],"CorrectAnswerIndex":0,"Explanation":"Forward Rendering (прямая отрисовка):\nДля каждого объекта в сцене происходит отдельная проходка всех источников света и материалов, чтобы получить итоговое изображение на экране.\nDeferred Rendering (отложенная отрисовка):\nДля каждого объекта в сцене происходит отдельная проходка для сбора информации о его свойствах.\nЗатем происходит отдельный проход для вычисления освещения на основе собранных данных, что позволяет уменьшить количество проходов по сравнению с forward rendering.\nDeferred rendering хорошо работает с большим количеством источников света и объектов, что предпочтительно в крупных и сложных сценах.\nВ то время как forward rendering прост и эффективен для маленьких сцен и устройств с ограниченными возможностями. ","Difficulty":98}]}